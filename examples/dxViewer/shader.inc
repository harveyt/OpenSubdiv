"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"struct OutputPointVertex {\n"
"    float4 positionOut : SV_Position;\n"
"};\n"
"\n"
"// ---------------------------------------------------------------------------\n"
"//  Vertex Shader\n"
"// ---------------------------------------------------------------------------\n"
"\n"
"void vs_main( in InputVertex input,\n"
"              out OutputVertex output )\n"
"{\n"
"    output.positionOut = mul(ModelViewProjectionMatrix, input.position);\n"
"    output.position = mul(ModelViewMatrix, input.position);\n"
"    output.normal = mul(ModelViewMatrix,float4(input.normal, 0)).xyz;\n"
"}\n"
"\n"
"// ---------------------------------------------------------------------------\n"
"//  Geometry Shader\n"
"// ---------------------------------------------------------------------------\n"
"\n"
"OutputVertex\n"
"outputVertex(OutputVertex input, float3 normal)\n"
"{\n"
"    OutputVertex v = input;\n"
"    v.normal = normal;\n"
"    return v;\n"
"}\n"
"\n"
"#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)\n"
"#ifdef PRIM_TRI\n"
"    #define EDGE_VERTS 3\n"
"#endif\n"
"#ifdef PRIM_QUAD\n"
"    #define EDGE_VERTS 4\n"
"#endif\n"
"\n"
"static float VIEWPORT_SCALE = 1024.0; // XXXdyu\n"
"\n"
"float edgeDistance(float2 p, float2 p0, float2 p1)\n"
"{\n"
"    return VIEWPORT_SCALE *\n"
"        abs((p.x - p0.x) * (p1.y - p0.y) -\n"
"            (p.y - p0.y) * (p1.x - p0.x)) / length(p1.xy - p0.xy);\n"
"}\n"
"\n"
"OutputVertex\n"
"outputWireVertex(OutputVertex input, float3 normal,\n"
"                 int index, float2 edgeVerts[EDGE_VERTS])\n"
"{\n"
"    OutputVertex v = input;\n"
"    v.normal = normal;\n"
"\n"
"    v.edgeDistance[0] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[0], edgeVerts[1]);\n"
"    v.edgeDistance[1] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[1], edgeVerts[2]);\n"
"#ifdef PRIM_TRI\n"
"    v.edgeDistance[2] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[2], edgeVerts[0]);\n"
"#endif\n"
"#ifdef PRIM_QUAD\n"
"    v.edgeDistance[2] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[2], edgeVerts[3]);\n"
"    v.edgeDistance[3] =\n"
"        edgeDistance(edgeVerts[index], edgeVerts[3], edgeVerts[0]);\n"
"#endif\n"
"\n"
"    return v;\n"
"}\n"
"#endif\n"
"\n"
"[maxvertexcount(6)]\n"
"void gs_quad( lineadj OutputVertex input[4],\n"
"              inout TriangleStream<OutputVertex> triStream )\n"
"{\n"
"    float3 A = (input[0].position - input[1].position).xyz;\n"
"    float3 B = (input[3].position - input[1].position).xyz;\n"
"    float3 C = (input[2].position - input[1].position).xyz;\n"
"\n"
"    float3 n0 = normalize(cross(B, A));\n"
"\n"
"    triStream.Append(outputVertex(input[0], n0));\n"
"    triStream.Append(outputVertex(input[1], n0));\n"
"    triStream.Append(outputVertex(input[3], n0));\n"
"    triStream.RestartStrip();\n"
"    triStream.Append(outputVertex(input[3], n0));\n"
"    triStream.Append(outputVertex(input[1], n0));\n"
"    triStream.Append(outputVertex(input[2], n0));\n"
"    triStream.RestartStrip();\n"
"}\n"
"\n"
"#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)\n"
"#ifdef PRIM_QUAD\n"
"[maxvertexcount(6)]\n"
"void gs_quad_wire( lineadj OutputVertex input[4],\n"
"              inout TriangleStream<OutputVertex> triStream )\n"
"{\n"
"    float3 A = (input[0].position - input[1].position).xyz;\n"
"    float3 B = (input[3].position - input[1].position).xyz;\n"
"    float3 C = (input[2].position - input[1].position).xyz;\n"
"\n"
"    float3 n0 = normalize(cross(B, A));\n"
"\n"
"    float2 edgeVerts[4];\n"
"    edgeVerts[0] = input[0].positionOut.xy / input[0].positionOut.w;\n"
"    edgeVerts[1] = input[1].positionOut.xy / input[1].positionOut.w;\n"
"    edgeVerts[2] = input[2].positionOut.xy / input[2].positionOut.w;\n"
"    edgeVerts[3] = input[3].positionOut.xy / input[3].positionOut.w;\n"
"\n"
"    triStream.Append(outputWireVertex(input[0], n0, 0, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[1], n0, 1, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[3], n0, 3, edgeVerts));\n"
"    triStream.RestartStrip();\n"
"    triStream.Append(outputWireVertex(input[3], n0, 3, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[1], n0, 1, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[2], n0, 2, edgeVerts));\n"
"    triStream.RestartStrip();\n"
"}\n"
"#endif\n"
"#endif\n"
"\n"
"[maxvertexcount(3)]\n"
"void gs_triangle( triangle OutputVertex input[3],\n"
"                  inout TriangleStream<OutputVertex> triStream )\n"
"{\n"
"    float3 A = (input[0].position - input[1].position).xyz;\n"
"    float3 B = (input[2].position - input[1].position).xyz;\n"
"\n"
"    float3 n0 = normalize(cross(B, A));\n"
"\n"
"    triStream.Append(outputVertex(input[0], n0));\n"
"    triStream.Append(outputVertex(input[1], n0));\n"
"    triStream.Append(outputVertex(input[2], n0));\n"
"}\n"
"\n"
"[maxvertexcount(3)]\n"
"void gs_triangle_smooth( triangle OutputVertex input[3],\n"
"                         inout TriangleStream<OutputVertex> triStream )\n"
"{\n"
"    triStream.Append(outputVertex(input[0], input[0].normal));\n"
"    triStream.Append(outputVertex(input[1], input[1].normal));\n"
"    triStream.Append(outputVertex(input[2], input[2].normal));\n"
"}\n"
"\n"
"#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)\n"
"#ifdef PRIM_TRI\n"
"[maxvertexcount(3)]\n"
"void gs_triangle_wire( triangle OutputVertex input[3],\n"
"                       inout TriangleStream<OutputVertex> triStream )\n"
"{\n"
"    float3 A = (input[0].position - input[1].position).xyz;\n"
"    float3 B = (input[2].position - input[1].position).xyz;\n"
"\n"
"    float3 n0 = normalize(cross(B, A));\n"
"\n"
"    float2 edgeVerts[3];\n"
"    edgeVerts[0] = input[0].positionOut.xy / input[0].positionOut.w;\n"
"    edgeVerts[1] = input[1].positionOut.xy / input[1].positionOut.w;\n"
"    edgeVerts[2] = input[2].positionOut.xy / input[2].positionOut.w;\n"
"\n"
"    triStream.Append(outputWireVertex(input[0], n0, 0, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[1], n0, 1, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[2], n0, 2, edgeVerts));\n"
"}\n"
"\n"
"[maxvertexcount(3)]\n"
"void gs_triangle_smooth_wire( triangle OutputVertex input[3],\n"
"                              inout TriangleStream<OutputVertex> triStream )\n"
"{\n"
"    float2 edgeVerts[3];\n"
"    edgeVerts[0] = input[0].positionOut.xy / input[0].positionOut.w;\n"
"    edgeVerts[1] = input[1].positionOut.xy / input[1].positionOut.w;\n"
"    edgeVerts[2] = input[2].positionOut.xy / input[2].positionOut.w;\n"
"\n"
"    triStream.Append(outputWireVertex(input[0], input[0].normal, 0, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[1], input[1].normal, 1, edgeVerts));\n"
"    triStream.Append(outputWireVertex(input[2], input[2].normal, 2, edgeVerts));\n"
"}\n"
"#endif\n"
"#endif\n"
"\n"
"[maxvertexcount(1)]\n"
"void gs_point( point OutputVertex input[1],\n"
"               inout PointStream<OutputPointVertex> pointStream )\n"
"{\n"
"    OutputPointVertex v0;\n"
"    v0.positionOut = input[0].positionOut;\n"
"\n"
"    pointStream.Append(v0);\n"
"}\n"
"\n"
"// ---------------------------------------------------------------------------\n"
"//  Lighting\n"
"// ---------------------------------------------------------------------------\n"
"\n"
"#define NUM_LIGHTS 2\n"
"\n"
"struct LightSource {\n"
"    float4 position;\n"
"    float4 ambient;\n"
"    float4 diffuse;\n"
"    float4 specular;\n"
"};\n"
"\n"
"cbuffer Lighting : register( b2 ) {\n"
"    LightSource lightSource[NUM_LIGHTS];\n"
"};\n"
"\n"
"float4\n"
"lighting(float3 Peye, float3 Neye)\n"
"{\n"
"    float4 color = float4(0.0, 0.0, 0.0, 0.0);\n"
"    //float4 material = float4(0.4, 0.4, 0.8, 1);\n"
"    float4 material = float4(0.13, 0.13, 0.61, 1); // sRGB (gamma 2.2)\n"
"\n"
"    for (int i = 0; i < NUM_LIGHTS; ++i) {\n"
"\n"
"        float4 Plight = lightSource[i].position;\n"
"\n"
"        float3 l = (Plight.w == 0.0)\n"
"                    ? normalize(Plight.xyz) : normalize(Plight.xyz - Peye);\n"
"\n"
"        float3 n = normalize(Neye);\n"
"        float3 h = normalize(l + float3(0,0,1));    // directional viewer\n"
"\n"
"        float d = max(0.0, dot(n, l));\n"
"        float s = pow(max(0.0, dot(n, h)), 500.0f);\n"
"\n"
"        color += lightSource[i].ambient * material\n"
"            + d * lightSource[i].diffuse * material\n"
"            + s * lightSource[i].specular;\n"
"    }\n"
"\n"
"\n"
"    color.a = 1.0;\n"
"    return color;\n"
"}\n"
"\n"
"// ---------------------------------------------------------------------------\n"
"//  Pixel Shader\n"
"// ---------------------------------------------------------------------------\n"
"\n"
"float4\n"
"edgeColor(float4 Cfill, float4 edgeDistance)\n"
"{\n"
"#if defined(GEOMETRY_OUT_WIRE) || defined(GEOMETRY_OUT_LINE)\n"
"#ifdef PRIM_TRI\n"
"    float d =\n"
"        min(edgeDistance[0], min(edgeDistance[1], edgeDistance[2]));\n"
"#endif\n"
"#ifdef PRIM_QUAD\n"
"    float d =\n"
"        min(min(edgeDistance[0], edgeDistance[1]),\n"
"            min(edgeDistance[2], edgeDistance[3]));\n"
"#endif\n"
"    float4 Cedge = float4(1.0, 1.0, 0.0, 1.0);\n"
"    float p = exp2(-2 * d * d);\n"
"\n"
"#if defined(GEOMETRY_OUT_WIRE)\n"
"    if (p < 0.25) discard;\n"
"#endif\n"
"\n"
"    Cfill.rgb = lerp(Cfill.rgb, Cedge.rgb, p);\n"
"#endif\n"
"    return Cfill;\n"
"}\n"
"\n"
"// ---------------------------------------------------------------------------\n"
"//  Pixel Shader\n"
"// ---------------------------------------------------------------------------\n"
"\n"
"void\n"
"ps_main( in OutputVertex input,\n"
"         bool isFrontFacing : SV_IsFrontFace,\n"
"         out float4 colorOut : SV_Target )\n"
"{\n"
"    float3 N = (isFrontFacing ? input.normal : -input.normal);\n"
"    colorOut = edgeColor(lighting(input.position.xyz, N), input.edgeDistance);\n"
"}\n"
"\n"
"void\n"
"ps_main_point( in OutputPointVertex input,\n"
"               out float4 colorOut : SV_Target )\n"
"{\n"
"    colorOut = float4(1, 1, 1, 1);\n"
"}\n"
"\n"
