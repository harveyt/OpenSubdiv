"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessVertexBSpline\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_VERTEX_BSPLINE_SHADER\n"
"\n"
"layout(location = 0) in vec4 position;\n"
"OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"\n"
"out block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    outpt.v.position = ModelViewMatrix * position;\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(position);\n"
"    OSD_USER_VARYING_PER_VERTEX();\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessControlBSpline\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_CONTROL_BSPLINE_SHADER\n"
"\n"
"// Regular\n"
"uniform mat4 Q = mat4(\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f\n"
");\n"
"\n"
"// Boundary / Corner\n"
"uniform mat4x3 B = mat4x3( \n"
"    1.f,     0.f,     0.f,\n"
"    4.f/6.f, 2.f/6.f, 0.f,\n"
"    2.f/6.f, 4.f/6.f, 0.f,\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f\n"
");\n"
"\n"
"layout(vertices = 16) out;\n"
"\n"
"in block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt[];\n"
"\n"
"#define ID gl_InvocationID\n"
"\n"
"void main()\n"
"{\n"
"    int i = ID%4;\n"
"    int j = ID/4;\n"
"\n"
"#if defined OSD_PATCH_BOUNDARY\n"
"    vec3 H[3];\n"
"    for (int l=0; l<3; ++l) {\n"
"        H[l] = vec3(0,0,0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * inpt[l*4 + k].v.position.xyz;\n"
"        }\n"
"    }\n"
"\n"
"    vec3 pos = vec3(0,0,0);\n"
"    for (int k=0; k<3; ++k) {\n"
"        pos += B[j][k]*H[k];\n"
"    }\n"
"\n"
"#elif defined OSD_PATCH_CORNER\n"
"    vec3 H[3];\n"
"    for (int l=0; l<3; ++l) {\n"
"        H[l] = vec3(0,0,0);\n"
"        for (int k=0; k<3; ++k) {\n"
"            H[l] += B[3-i][2-k] * inpt[l*3 + k].v.position.xyz;\n"
"        }\n"
"    }\n"
"\n"
"    vec3 pos = vec3(0,0,0);\n"
"    for (int k=0; k<3; ++k) {\n"
"        pos += B[j][k]*H[k];\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_BOUNDARY, not OSD_PATCH_CORNER\n"
"    vec3 H[4];\n"
"    for (int l=0; l<4; ++l) {\n"
"        H[l] = vec3(0,0,0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * inpt[l*4 + k].v.position.xyz;\n"
"        }\n"
"    }\n"
"\n"
"    vec3 pos = vec3(0,0,0);\n"
"    for (int k=0; k<4; ++k) {\n"
"        pos += Q[j][k]*H[k];\n"
"    }\n"
"\n"
"#endif\n"
"\n"
"    outpt[ID].v.position = vec4(pos, 1.0);\n"
"\n"
"#if defined OSD_PATCH_BOUNDARY\n"
"    const int p[16] = int[]( 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 );\n"
"#elif defined OSD_PATCH_CORNER\n"
"    const int p[16] = int[]( 0, 1, 2, 2, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 8 );\n"
"#else\n"
"    const int p[16] = int[]( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );\n"
"#endif\n"
"\n"
"#if OSD_TRANSITION_ROTATE == 0\n"
"    const int r[16] = int[]( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );\n"
"#elif OSD_TRANSITION_ROTATE == 1\n"
"    const int r[16] = int[]( 12, 8, 4, 0, 13, 9, 5, 1, 14, 10, 6, 2, 15, 11, 7, 3 );\n"
"#elif OSD_TRANSITION_ROTATE == 2\n"
"    const int r[16] = int[]( 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 );\n"
"#elif OSD_TRANSITION_ROTATE == 3\n"
"    const int r[16] = int[]( 3, 7, 11, 15, 2, 6, 10, 14, 1, 5, 9, 13, 0, 4, 8, 12 );\n"
"#endif\n"
"\n"
"    OSD_USER_VARYING_PER_CONTROL_POINT(ID, p[r[ID]]);\n"
"\n"
"    int patchLevel = GetPatchLevel();\n"
"\n"
"    // +0.5 to avoid interpolation error of integer value\n"
"    outpt[ID].v.patchCoord = vec4(0, 0,\n"
"                                  patchLevel+0.5,\n"
"                                  gl_PrimitiveID+OsdPrimitiveIdBase+0.5);\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_TESSCONTROL_SHADER;\n"
"\n"
"    if (ID == 0) {\n"
"        OSD_PATCH_CULL(OSD_PATCH_INPUT_SIZE);\n"
"\n"
"#ifdef OSD_PATCH_TRANSITION\n"
"        vec3 cp[OSD_PATCH_INPUT_SIZE];\n"
"        for(int k = 0; k < OSD_PATCH_INPUT_SIZE; ++k) cp[k] = inpt[k].v.position.xyz;\n"
"        SetTransitionTessLevels(cp, patchLevel);\n"
"#else\n"
"    #if defined OSD_PATCH_BOUNDARY\n"
"        const int p[4] = int[]( 1, 2, 5, 6 );\n"
"    #elif defined OSD_PATCH_CORNER\n"
"        const int p[4] = int[]( 1, 2, 4, 5 );\n"
"    #else\n"
"        const int p[4] = int[]( 5, 6, 9, 10 );\n"
"    #endif\n"
"\n"
"    #ifdef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        gl_TessLevelOuter[0] = TessAdaptive(inpt[p[0]].v.position.xyz, inpt[p[2]].v.position.xyz);\n"
"        gl_TessLevelOuter[1] = TessAdaptive(inpt[p[0]].v.position.xyz, inpt[p[1]].v.position.xyz);\n"
"        gl_TessLevelOuter[2] = TessAdaptive(inpt[p[1]].v.position.xyz, inpt[p[3]].v.position.xyz);\n"
"        gl_TessLevelOuter[3] = TessAdaptive(inpt[p[2]].v.position.xyz, inpt[p[3]].v.position.xyz);\n"
"        gl_TessLevelInner[0] = max(gl_TessLevelOuter[1], gl_TessLevelOuter[3]);\n"
"        gl_TessLevelInner[1] = max(gl_TessLevelOuter[0], gl_TessLevelOuter[2]);\n"
"    #else\n"
"        gl_TessLevelInner[0] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelInner[1] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[0] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[1] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[2] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[3] = GetTessLevel(patchLevel);\n"
"    #endif\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessEvalBSpline\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_EVAL_BSPLINE_SHADER\n"
"\n"
"#ifdef OSD_TRANSITION_TRIANGLE_SUBPATCH\n"
"    layout(triangles) in;\n"
"#else\n"
"    layout(quads) in;\n"
"#endif\n"
"\n"
"#if defined OSD_FRACTIONAL_ODD_SPACING\n"
"    layout(fractional_odd_spacing) in;\n"
"#elif defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    layout(fractional_even_spacing) in;\n"
"#endif\n"
"\n"
"in block {\n"
"    ControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"#ifdef OSD_PATCH_TRANSITION\n"
"    vec2 UV = GetTransitionSubpatchUV();\n"
"#else\n"
"    vec2 UV = gl_TessCoord.xy;\n"
"#endif\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    float B[4], D[4], C[4];\n"
"    vec3 BUCP[4], DUCP[4], CUCP[4];\n"
"    Univar4x4(UV.x, B, D, C);\n"
"#else\n"
"    float B[4], D[4];\n"
"    vec3 BUCP[4], DUCP[4];\n"
"    Univar4x4(UV.x, B, D);\n"
"#endif\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        BUCP[i] = vec3(0);\n"
"        DUCP[i] = vec3(0);\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"        CUCP[i] = vec3(0);\n"
"#endif\n"
"\n"
"        for (int j=0; j<4; ++j) {\n"
"#if OSD_TRANSITION_ROTATE == 1\n"
"            vec3 A = inpt[4*(3-j) + i].v.position.xyz;\n"
"#elif OSD_TRANSITION_ROTATE == 2\n"
"            vec3 A = inpt[4*(3-i) + (3-j)].v.position.xyz;\n"
"#elif OSD_TRANSITION_ROTATE == 3\n"
"            vec3 A = inpt[4*j + (3-i)].v.position.xyz;\n"
"#else // OSD_TRANSITION_ROTATE == 0, or non-transition patch\n"
"            vec3 A = inpt[4*i + j].v.position.xyz;\n"
"#endif\n"
"            BUCP[i] += A * B[j];\n"
"            DUCP[i] += A * D[j];\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"            CUCP[i] += A * C[j];\n"
"#endif\n"
"        }\n"
"    }\n"
"\n"
"    vec3 WorldPos  = vec3(0);\n"
"    vec3 Tangent   = vec3(0);\n"
"    vec3 BiTangent = vec3(0);\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    // used for weingarten term\n"
"    Univar4x4(UV.y, B, D, C);\n"
"\n"
"    vec3 dUU = vec3(0);\n"
"    vec3 dVV = vec3(0);\n"
"    vec3 dUV = vec3(0);\n"
"\n"
"    for (int k=0; k<4; ++k) {\n"
"        WorldPos  += B[k] * BUCP[k];\n"
"        Tangent   += B[k] * DUCP[k];\n"
"        BiTangent += D[k] * BUCP[k];\n"
"\n"
"        dUU += B[k] * CUCP[k];\n"
"        dVV += C[k] * BUCP[k];\n"
"        dUV += D[k] * DUCP[k];\n"
"    }\n"
"\n"
"    int level = int(inpt[0].v.ptexInfo.z);\n"
"    Tangent *= 3 * level;\n"
"    BiTangent *= 3 * level;\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    vec3 n = cross(Tangent, BiTangent);\n"
"    vec3 normal = normalize(n);\n"
"\n"
"    float E = dot(Tangent, Tangent);\n"
"    float F = dot(Tangent, BiTangent);\n"
"    float G = dot(BiTangent, BiTangent);\n"
"    float e = dot(normal, dUU);\n"
"    float f = dot(normal, dUV);\n"
"    float g = dot(normal, dVV);\n"
"\n"
"    vec3 Nu = (f*F-e*G)/(E*G-F*F) * Tangent + (e*F-f*E)/(E*G-F*F) * BiTangent;\n"
"    vec3 Nv = (g*F-f*G)/(E*G-F*F) * Tangent + (f*F-g*E)/(E*G-F*F) * BiTangent;\n"
"\n"
"    Nu = Nu/length(n) - n * (dot(Nu,n)/pow(dot(n,n), 1.5));\n"
"    Nv = Nv/length(n) - n * (dot(Nv,n)/pow(dot(n,n), 1.5));\n"
"\n"
"    OSD_COMPUTE_PTEX_COMPATIBLE_DERIVATIVES(OSD_TRANSITION_ROTATE);\n"
"#else\n"
"    Univar4x4(UV.y, B, D);\n"
"\n"
"    for (int k=0; k<4; ++k) {\n"
"        WorldPos  += B[k] * BUCP[k];\n"
"        Tangent   += B[k] * DUCP[k];\n"
"        BiTangent += D[k] * BUCP[k];\n"
"    }\n"
"    int level = int(inpt[0].v.ptexInfo.z);\n"
"    Tangent *= 3 * level;\n"
"    BiTangent *= 3 * level;\n"
"\n"
"    vec3 normal = normalize(cross(Tangent, BiTangent));\n"
"\n"
"    OSD_COMPUTE_PTEX_COMPATIBLE_TANGENT(OSD_TRANSITION_ROTATE);\n"
"#endif\n"
"\n"
"    outpt.v.position = vec4(WorldPos, 1.0f);\n"
"    outpt.v.normal = normal;\n"
"\n"
"    OSD_USER_VARYING_PER_EVAL_POINT(UV, 5, 6, 9, 10);\n"
"\n"
"    outpt.v.patchCoord = inpt[0].v.patchCoord;\n"
"\n"
"#if OSD_TRANSITION_ROTATE == 1\n"
"    outpt.v.patchCoord.xy = vec2(UV.y, 1.0-UV.x);\n"
"#elif OSD_TRANSITION_ROTATE == 2\n"
"    outpt.v.patchCoord.xy = vec2(1.0-UV.x, 1.0-UV.y);\n"
"#elif OSD_TRANSITION_ROTATE == 3\n"
"    outpt.v.patchCoord.xy = vec2(1.0-UV.y, UV.x);\n"
"#else // OSD_TRANNSITION_ROTATE == 0, or non-transition patch\n"
"    outpt.v.patchCoord.xy = vec2(UV.x, UV.y);\n"
"#endif\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_TESSEVAL_SHADER;\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    gl_Position = (ProjectionMatrix * vec4(WorldPos, 1.0f));\n"
"}\n"
"\n"
"#endif\n"
"\n"
