"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"interface IComputeKernel {\n"
"    void runKernel( uint3 ID );\n"
"};\n"
"IComputeKernel kernel;\n"
"\n"
"cbuffer KernelCB : register( b0 ) {\n"
"    int vertexOffset;   // vertex index offset for the batch\n"
"    int tableOffset;    // offset of subdivision table\n"
"    int indexStart;     // start index relative to tableOffset\n"
"    int indexEnd;       // end index relative to tableOffset\n"
"    bool vertexPass;\n"
"\n"
"// vertex edit kernel\n"
"    int editPrimVarOffset;\n"
"    int editPrimVarWidth;\n"
"};\n"
"\n"
"/*\n"
" +-----+---------------------------------+-----\n"
"   n-1 |   Level n   |<batch range>|     |  n+1\n"
" +-----+---------------------------------+-----\n"
"       ^             ^             ^\n"
"  vertexOffset       |             |\n"
"                 indexStart     indexEnd\n"
"*/\n"
"\n"
"RWBuffer<float> vertexBuffer  : register( u0 );\n"
"RWBuffer<float> varyingBuffer : register( u1 );\n"
"Buffer<int> _F_IT             : register( t2 );\n"
"Buffer<int> _F_ITa            : register( t3 );\n"
"Buffer<int> _E_IT             : register( t4 );\n"
"Buffer<int> _V_IT             : register( t5 );\n"
"Buffer<int> _V_ITa            : register( t6 );\n"
"Buffer<float> _E_W            : register( t7 );\n"
"Buffer<float> _V_W            : register( t8 );\n"
"Buffer<int> _editIndices      : register( t9 );\n"
"Buffer<float> _editValues     : register( t10 );\n"
"\n"
"//--------------------------------------------------------------------------------\n"
"\n"
"struct Vertex\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    float vertexData[NUM_VERTEX_ELEMENTS];\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    float varyingData[NUM_VARYING_ELEMENTS];\n"
"#endif\n"
"};\n"
"\n"
"void clear(out Vertex v)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VARYING_ELEMENTS; i++){\n"
"        v.varyingData[i] = 0;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"Vertex readVertex(int index)\n"
"{\n"
"    Vertex v;\n"
"\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] = vertexBuffer[index*NUM_VERTEX_ELEMENTS+i];\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        v.varyingData[i] = varyingBuffer[index*NUM_VARYING_ELEMENTS+i];\n"
"    }\n"
"#endif\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(int index, Vertex v)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        vertexBuffer[index*NUM_VERTEX_ELEMENTS+i] = v.vertexData[i];\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        varyingBuffer[index*NUM_VARYING_ELEMENTS+i] = v.varyingData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, Vertex src, float weight)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] += weight * src.vertexData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void addVaryingWithWeight(inout Vertex v, Vertex src, float weight)\n"
"{\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        v.varyingData[i] += weight * src.varyingData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"//--------------------------------------------------------------------------------\n"
"// Face-vertices compute Kernel\n"
"class CatmarkComputeFace : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int h = _F_ITa[2*i];\n"
"    int n = _F_ITa[2*i+1];\n"
"\n"
"    float weight = 1.0/n;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"    for(int j=0; j<n; ++j){\n"
"        int index = _F_IT[h+j];\n"
"        addWithWeight(dst, readVertex(index), weight);\n"
"        addVaryingWithWeight(dst, readVertex(index), weight);\n"
"    }\n"
"    writeVertex(vid, dst);\n"
"}\n"
"};\n"
"\n"
"// Edge-vertices compute Kernel\n"
"class CatmarkComputeEdge : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int eidx0 = _E_IT[4*i+0];\n"
"    int eidx1 = _E_IT[4*i+1];\n"
"    int eidx2 = _E_IT[4*i+2];\n"
"    int eidx3 = _E_IT[4*i+3];\n"
"    int4 eidx = int4(eidx0, eidx1, eidx2, eidx3);\n"
"\n"
"    float vertWeight = _E_W[i*2+0];\n"
"\n"
"    // Fully sharp edge : vertWeight = 0.5f;\n"
"    addWithWeight(dst, readVertex(eidx.x), vertWeight);\n"
"    addWithWeight(dst, readVertex(eidx.y), vertWeight);\n"
"\n"
"    if(eidx.z != -1){\n"
"        float faceWeight = _E_W[i*2+1];\n"
"\n"
"        addWithWeight(dst, readVertex(eidx.z), faceWeight);\n"
"        addWithWeight(dst, readVertex(eidx.w), faceWeight);\n"
"    }\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addVaryingWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"};\n"
"\n"
"// Edge-vertices compute Kernel (bilinear scheme)\n"
"class BilinearComputeEdge : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int2 eidx = int2(_E_IT[2*i+0],\n"
"                     _E_IT[2*i+1]);\n"
"\n"
"    addWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addVaryingWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"};\n"
"\n"
"// Vertex-vertices compute Kernel (bilinear scheme)\n"
"class BilinearComputeVertex : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int p = _V_ITa[i];\n"
"\n"
"    addWithWeight(dst, readVertex(p), 1.0f);\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(p), 1.0f);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"};\n"
"\n"
"// Vertex-vertices compute Kernels 'A' / k_Crease and k_Corner rules\n"
"class CatmarkComputeVertexA : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int n     = _V_ITa[5*i+1];\n"
"    int p     = _V_ITa[5*i+2];\n"
"    int eidx0 = _V_ITa[5*i+3];\n"
"    int eidx1 = _V_ITa[5*i+4];\n"
"\n"
"    float weight = vertexPass\n"
"        ? _V_W[i]\n"
"        : 1.0 - _V_W[i];\n"
"\n"
"    // In the case of fractional weight, the weight must be inverted since\n"
"    // the value is shared with the k_Smooth kernel (statistically the\n"
"    // k_Smooth kernel runs much more often than this one)\n"
"    if (weight>0.0 && weight<1.0 && n > 0)\n"
"        weight=1.0-weight;\n"
"\n"
"    Vertex dst;\n"
"    if(! vertexPass)\n"
"        clear(dst);\n"
"    else\n"
"        dst = readVertex(vid);\n"
"\n"
"    if (eidx0==-1 || (vertexPass==false && (n==-1)) ) {\n"
"        addWithWeight(dst, readVertex(p), weight);\n"
"    } else {\n"
"        addWithWeight(dst, readVertex(p), weight * 0.75f);\n"
"        addWithWeight(dst, readVertex(eidx0), weight * 0.125f);\n"
"        addWithWeight(dst, readVertex(eidx1), weight * 0.125f);\n"
"    }\n"
"    if(! vertexPass)\n"
"        addVaryingWithWeight(dst, readVertex(p), 1);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"};\n"
"\n"
"// Vertex-vertices compute Kernels 'B' / k_Dart and k_Smooth rules\n"
"class CatmarkComputeVertexB : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int h = _V_ITa[5*i];\n"
"    int n = _V_ITa[5*i+1];\n"
"    int p = _V_ITa[5*i+2];\n"
"\n"
"    float weight = _V_W[i];\n"
"    float wp = 1.0/float(n*n);\n"
"    float wv = (n-2.0) * n * wp;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    addWithWeight(dst, readVertex(p), weight * wv);\n"
"\n"
"    for(int j = 0; j < n; ++j){\n"
"        addWithWeight(dst, readVertex(_V_IT[h+j*2]), weight * wp);\n"
"        addWithWeight(dst, readVertex(_V_IT[h+j*2+1]), weight * wp);\n"
"    }\n"
"    addVaryingWithWeight(dst, readVertex(p), 1);\n"
"    writeVertex(vid, dst);\n"
"}\n"
"};\n"
"\n"
"// Vertex-vertices compute Kernels 'B' / k_Dart and k_Smooth rules\n"
"class LoopComputeVertexB : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    float PI = 3.14159265358979323846264;\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int h = _V_ITa[5*i];\n"
"    int n = _V_ITa[5*i+1];\n"
"    int p = _V_ITa[5*i+2];\n"
"\n"
"    float weight = _V_W[i];\n"
"    float wp = 1.0/n;\n"
"    float beta = 0.25 * cos(PI*2.0f*wp)+0.375f;\n"
"    beta = beta * beta;\n"
"    beta = (0.625f-beta)*wp;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    addWithWeight(dst, readVertex(p), weight * (1.0-(beta*n)));\n"
"\n"
"    for(int j = 0; j < n; ++j){\n"
"        addWithWeight(dst, readVertex(_V_IT[h+j]), weight * beta);\n"
"    }\n"
"    addVaryingWithWeight(dst, readVertex(p), 1);\n"
"    writeVertex(vid, dst);\n"
"}\n"
"};\n"
"\n"
"class EditAdd : IComputeKernel {\n"
"int placeholder;\n"
"void runKernel( uint3 ID )\n"
"{\n"
"    int i = int(ID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    i += tableOffset;\n"
"\n"
"    int v = _editIndices[i];\n"
"    Vertex dst = readVertex(v + vertexOffset);\n"
"\n"
"    // seemingly we can't iterate dynamically over vertexData[n]\n"
"    // due to mysterious glsl runtime limitation...?\n"
"    for (int j = 0; j < NUM_VERTEX_ELEMENTS; ++j) {\n"
"        float editValue = _editValues[i*editPrimVarOffset+min(j, editPrimVarWidth)];\n"
"        editValue *= float(j >= editPrimVarOffset);\n"
"        editValue *= float(j < (editPrimVarWidth + editPrimVarOffset));\n"
"        dst.vertexData[j] += editValue;\n"
"    }\n"
"    writeVertex(v + vertexOffset, dst);\n"
"}\n"
"};\n"
"\n"
"CatmarkComputeFace catmarkComputeFace;\n"
"CatmarkComputeEdge catmarkComputeEdge;\n"
"BilinearComputeEdge bilinearComputeEdge;\n"
"BilinearComputeVertex bilinearComputeVertex;\n"
"CatmarkComputeVertexA catmarkComputeVertexA;\n"
"CatmarkComputeVertexB catmarkComputeVertexB;\n"
"LoopComputeVertexB loopComputeVertexB;\n"
"EditAdd editAdd;\n"
"\n"
"[numthreads(WORK_GROUP_SIZE, 1, 1)]\n"
"void cs_main( uint3 ID : SV_DispatchThreadID )\n"
"{\n"
"    // call kernel\n"
"    kernel.runKernel(ID);\n"
"}\n"
"\n"
