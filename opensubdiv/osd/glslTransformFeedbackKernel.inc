"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#version 420\n"
"\n"
"subroutine void computeKernelType();\n"
"subroutine uniform computeKernelType computeKernel;\n"
"\n"
"uniform isamplerBuffer _F0_IT;\n"
"uniform isamplerBuffer _F0_ITa;\n"
"uniform isamplerBuffer _E0_IT;\n"
"uniform isamplerBuffer _V0_IT;\n"
"uniform isamplerBuffer _V0_ITa;\n"
"uniform samplerBuffer _E0_S;\n"
"uniform samplerBuffer _V0_S;\n"
"uniform isamplerBuffer _editIndices;\n"
"uniform samplerBuffer _editValues;\n"
"layout(size1x32) uniform imageBuffer _vertexBufferImage;\n"
"\n"
"uniform int vertexOffset = 0;   // vertex index offset for the batch\n"
"uniform int tableOffset = 0;    // offset of subdivision table\n"
"uniform int indexStart = 0;     // start index relative to tableOffset\n"
"uniform bool vertexPass;\n"
"\n"
"/*\n"
" +-----+---------------------------------+-----\n"
"   n-1 |   Level n   |<batch range>|     |  n+1\n"
" +-----+---------------------------------+-----\n"
"       ^             ^\n"
"  vertexOffset       |\n"
"                 indexStart\n"
"*/\n"
"\n"
"//--------------------------------------------------------------------------------\n"
"\n"
"struct Vertex\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    float vertexData[NUM_VERTEX_ELEMENTS];\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    float varyingData[NUM_VARYING_ELEMENTS];\n"
"#endif\n"
"};\n"
"\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"uniform samplerBuffer vertexData;    // float[NUM_VERTEX_ELEMENTS]\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"uniform samplerBuffer varyingData;   // float[NUM_VARYING_ELEMENTS]\n"
"#endif\n"
"\n"
"// output feedback (mapped as a subrange of vertices)\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"out float outVertexData[NUM_VERTEX_ELEMENTS];\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"out float outVaryingData[NUM_VARYING_ELEMENTS];\n"
"#endif\n"
"\n"
"void clear(out Vertex v)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VARYING_ELEMENTS; i++){\n"
"        v.varyingData[i] = 0;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"Vertex readVertex(int index)\n"
"{\n"
"    // XXX: should be split into two parts for addWithWeight and addVaryingWithWeight\n"
"    Vertex v;\n"
"\n"
"    // unpacking\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] = texelFetch(vertexData, index*NUM_VERTEX_ELEMENTS+i).x;\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VARYING_ELEMENTS; i++){\n"
"        v.varyingData[i] = texelFetch(varyingData, index*NUM_VARYING_ELEMENTS+i).x;\n"
"    }\n"
"#endif\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(Vertex v)\n"
"{\n"
"    // packing\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        outVertexData[i] = v.vertexData[i];\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VARYING_ELEMENTS; i++){\n"
"        outVaryingData[i] = v.varyingData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void writeVertexByImageStore(Vertex v, int index)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    int p = index * NUM_VERTEX_ELEMENTS;\n"
"    for(int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        imageStore(_vertexBufferImage, p+i, vec4(v.vertexData[i], 0, 0, 0));\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, Vertex src, float weight)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] += weight * src.vertexData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void addVaryingWithWeight(inout Vertex v, Vertex src, float weight)\n"
"{\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VARYING_ELEMENTS; i++){\n"
"        v.varyingData[i] += weight * src.varyingData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"//--------------------------------------------------------------------------------\n"
"// Face-vertices compute Kernel\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeFace()\n"
"{\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"    int h = texelFetch(_F0_ITa, 2*i).x;\n"
"    int n = texelFetch(_F0_ITa, 2*i+1).x;\n"
"\n"
"    float weight = 1.0/n;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"    for(int j=0; j<n; ++j){\n"
"        int index = texelFetch(_F0_IT, h+j).x;\n"
"        addWithWeight(dst, readVertex(index), weight);\n"
"        addVaryingWithWeight(dst, readVertex(index), weight);\n"
"    }\n"
"    writeVertex(dst);\n"
"}\n"
"\n"
"// Edge-vertices compute Kernel\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeEdge()\n"
"{\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"#ifdef OPT_E0_IT_VEC4\n"
"    ivec4 eidx = texelFetch(_E0_IT, i);\n"
"#else\n"
"    int eidx0 = texelFetch(_E0_IT, 4*i+0).x;\n"
"    int eidx1 = texelFetch(_E0_IT, 4*i+1).x;\n"
"    int eidx2 = texelFetch(_E0_IT, 4*i+2).x;\n"
"    int eidx3 = texelFetch(_E0_IT, 4*i+3).x;\n"
"    ivec4 eidx = ivec4(eidx0, eidx1, eidx2, eidx3);\n"
"#endif\n"
"\n"
"#ifdef OPT_E0_S_VEC2\n"
"    vec2 weight = texelFetch(_E0_S, i).xy;\n"
"    float vertWeight = weight.x;\n"
"#else\n"
"    float vertWeight = texelFetch(_E0_S, i*2+0).x;\n"
"#endif\n"
"\n"
"    // Fully sharp edge : vertWeight = 0.5f;\n"
"    addWithWeight(dst, readVertex(eidx.x), vertWeight);\n"
"    addWithWeight(dst, readVertex(eidx.y), vertWeight);\n"
"\n"
"    if(eidx.z != -1){\n"
"#ifdef OPT_E0_S_VEC2\n"
"        float faceWeight = weight.y;\n"
"#else\n"
"        float faceWeight = texelFetch(_E0_S, i*2+1).x;\n"
"#endif\n"
"\n"
"        addWithWeight(dst, readVertex(eidx.z), faceWeight);\n"
"        addWithWeight(dst, readVertex(eidx.w), faceWeight);\n"
"    }\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addVaryingWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    writeVertex(dst);\n"
"}\n"
"\n"
"// Edge-vertices compute Kernel (bilinear scheme)\n"
"subroutine(computeKernelType)\n"
"void bilinearComputeEdge()\n"
"{\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"#ifdef OPT_E0_IT_VEC4\n"
"    ivec2 eidx = texelFetch(_E0_IT, i).xy;\n"
"#else\n"
"    ivec2 eidx = ivec2(texelFetch(_E0_IT, 2*i+0).x,\n"
"                       texelFetch(_E0_IT, 2*i+1).x);\n"
"#endif\n"
"\n"
"    addWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addVaryingWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    writeVertex(dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernel (bilinear scheme)\n"
"subroutine(computeKernelType)\n"
"void bilinearComputeVertex()\n"
"{\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int p = texelFetch(_V0_ITa, i).x;\n"
"\n"
"    addWithWeight(dst, readVertex(p), 1.0f);\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(p), 1.0f);\n"
"\n"
"    writeVertex(dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernels 'A' / k_Crease and k_Corner rules\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeVertexA()\n"
"{\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"    int vid = gl_VertexID + indexStart + vertexOffset;\n"
"\n"
"    int n     = texelFetch(_V0_ITa, 5*i+1).x;\n"
"    int p     = texelFetch(_V0_ITa, 5*i+2).x;\n"
"    int eidx0 = texelFetch(_V0_ITa, 5*i+3).x;\n"
"    int eidx1 = texelFetch(_V0_ITa, 5*i+4).x;\n"
"\n"
"    float weight = vertexPass\n"
"        ? texelFetch(_V0_S, i).x\n"
"        : 1.0 - texelFetch(_V0_S, i).x;\n"
"\n"
"    // In the case of fractional weight, the weight must be inverted since\n"
"    // the value is shared with the k_Smooth kernel (statistically the\n"
"    // k_Smooth kernel runs much more often than this one)\n"
"    if (weight>0.0 && weight<1.0 && n > 0)\n"
"        weight=1.0-weight;\n"
"\n"
"    Vertex dst;\n"
"    if(! vertexPass)\n"
"        clear(dst);\n"
"    else\n"
"        dst = readVertex(vid);\n"
"\n"
"    if (eidx0==-1 || (vertexPass==false && (n==-1)) ) {\n"
"        addWithWeight(dst, readVertex(p), weight);\n"
"    } else {\n"
"        addWithWeight(dst, readVertex(p), weight * 0.75f);\n"
"        addWithWeight(dst, readVertex(eidx0), weight * 0.125f);\n"
"        addWithWeight(dst, readVertex(eidx1), weight * 0.125f);\n"
"    }\n"
"    if(! vertexPass)\n"
"        addVaryingWithWeight(dst, readVertex(p), 1.0f);\n"
"\n"
"    writeVertex(dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernels 'B' / k_Dart and k_Smooth rules\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeVertexB()\n"
"{\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"\n"
"    int h = texelFetch(_V0_ITa, 5*i).x;\n"
"#ifdef OPT_CATMARK_V_IT_VEC2\n"
"    int h2 = h/2;\n"
"#endif\n"
"    int n = texelFetch(_V0_ITa, 5*i+1).x;\n"
"    int p = texelFetch(_V0_ITa, 5*i+2).x;\n"
"\n"
"    float weight = texelFetch(_V0_S, i).x;\n"
"    float wp = 1.0/float(n*n);\n"
"    float wv = (n-2.0) * n * wp;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    addWithWeight(dst, readVertex(p), weight * wv);\n"
"\n"
"    for(int j = 0; j < n; ++j){\n"
"#ifdef OPT_CATMARK_V_IT_VEC2\n"
"        ivec2 v0it = texelFetch(_V0_IT, h2+j).xy;\n"
"        addWithWeight(dst, readVertex(v0it.x), weight * wp);\n"
"        addWithWeight(dst, readVertex(v0it.y), weight * wp);\n"
"#else\n"
"        addWithWeight(dst, readVertex(texelFetch(_V0_IT, h+j*2).x), weight * wp);\n"
"        addWithWeight(dst, readVertex(texelFetch(_V0_IT, h+j*2+1).x), weight * wp);\n"
"#endif\n"
"    }\n"
"    addVaryingWithWeight(dst, readVertex(p), 1.0f);\n"
"    writeVertex(dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernels 'B' / k_Dart and k_Smooth rules\n"
"subroutine(computeKernelType)\n"
"void loopComputeVertexB()\n"
"{\n"
"    float PI = 3.14159265358979323846264;\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"\n"
"    int h = texelFetch(_V0_ITa, 5*i).x;\n"
"    int n = texelFetch(_V0_ITa, 5*i+1).x;\n"
"    int p = texelFetch(_V0_ITa, 5*i+2).x;\n"
"\n"
"    float weight = texelFetch(_V0_S, i).x;\n"
"    float wp = 1.0/n;\n"
"    float beta = 0.25 * cos(PI*2.0f*wp)+0.375f;\n"
"    beta = beta * beta;\n"
"    beta = (0.625f-beta)*wp;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    addWithWeight(dst, readVertex(p), weight * (1.0-(beta*n)));\n"
"\n"
"    for(int j = 0; j < n; ++j){\n"
"        addWithWeight(dst, readVertex(texelFetch(_V0_IT, h+j).x), weight * beta);\n"
"    }\n"
"    addVaryingWithWeight(dst, readVertex(p), 1.0f);\n"
"    writeVertex(dst);\n"
"}\n"
"\n"
"// vertex edit kernel\n"
"uniform int editPrimVarOffset;\n"
"uniform int editPrimVarWidth;\n"
"\n"
"subroutine(computeKernelType)\n"
"void editAdd()\n"
"{\n"
"    int i = gl_VertexID + indexStart + tableOffset;\n"
"\n"
"    int v = texelFetch(_editIndices, i).x;\n"
"    Vertex dst = readVertex(v + vertexOffset);\n"
"\n"
"    // this is tricky. _editValues array contains editPrimVarWidth count of values.\n"
"    // i.e. if the vertex edit is just for pos Y, editPrimVarOffset = 1 and\n"
"    // editPrimVarWidth = 1, then _editValues will be an one element array.\n"
"    // below loops iterate over every elements regardless editing values to be applied or not,\n"
"    // so we need to make out-of-range edits ineffective.\n"
"\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int j = 0; j < NUM_VERTEX_ELEMENTS; ++j) {\n"
"        int index = min(j-editPrimVarOffset, editPrimVarWidth-1);\n"
"        float editValue = texelFetch(_editValues, i*editPrimVarOffset + index).x;\n"
"        editValue *= float(j >= editPrimVarOffset);\n"
"        editValue *= float(j < (editPrimVarWidth + editPrimVarOffset));\n"
"        dst.vertexData[j] += editValue;\n"
"    }\n"
"#endif\n"
"    writeVertexByImageStore(dst, v + vertexOffset);\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"    // call subroutine\n"
"    computeKernel();\n"
"}\n"
"\n"
