"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#if defined OSD_FRACTIONAL_ODD_SPACING\n"
"    #define HS_PARTITION \"fractional_odd\"\n"
"#elif defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    #define HS_PARTITION \"fractional_even\"\n"
"#else\n"
"    #define HS_PARTITION \"integer\"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Coefficients\n"
"//----------------------------------------------------------\n"
"\n"
"#if OSD_MAX_VALENCE<=10\n"
"static float ef[7] = {\n"
"    0.813008, 0.500000, 0.363636, 0.287505,\n"
"    0.238692, 0.204549, 0.179211\n"
"};\n"
"#else\n"
"static float ef[27] = {\n"
"    0.812816, 0.500000, 0.363644, 0.287514,\n"
"    0.238688, 0.204544, 0.179229, 0.159657,\n"
"    0.144042, 0.131276, 0.120632, 0.111614,\n"
"    0.103872, 0.09715, 0.0912559, 0.0860444,\n"
"    0.0814022, 0.0772401, 0.0734867, 0.0700842,\n"
"    0.0669851, 0.0641504, 0.0615475, 0.0591488,\n"
"    0.0569311, 0.0548745, 0.0529621\n"
"};\n"
"#endif\n"
"\n"
"float csf(uint n, uint j)\n"
"{\n"
"    if (j%2 == 0) {\n"
"        return cos((2.0f * M_PI * float(float(j-0)/2.0f))/(float(n)+3.0f));\n"
"    } else {\n"
"        return sin((2.0f * M_PI * float(float(j-1)/2.0f))/(float(n)+3.0f));\n"
"    }\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessVertexGregory\n"
"//----------------------------------------------------------\n"
"\n"
"Buffer<float> OsdVertexBuffer : register( t0 );\n"
"Buffer<int> OsdValenceBuffer : register( t1 );\n"
"\n"
"void vs_main_patches( in InputVertex input,\n"
"                      uint vID : SV_VertexID,\n"
"                      out GregHullVertex output )\n"
"{\n"
"    output.hullPosition = mul(ModelViewMatrix, input.position).xyz;\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(input.position);\n"
"\n"
"    int ivalence = OsdValenceBuffer[int(vID * (2 * OSD_MAX_VALENCE + 1))];\n"
"    output.valence = ivalence;\n"
"    uint valence = uint(abs(ivalence));\n"
"\n"
"    float3 f[OSD_MAX_VALENCE]; \n"
"    float3 pos = input.position.xyz;\n"
"    float3 opos = float3(0,0,0);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    output.org = input.position.xyz;\n"
"    int boundaryEdgeNeighbors[2];\n"
"    uint currNeighbor = 0;\n"
"    uint ibefore = 0;\n"
"    uint zerothNeighbor = 0;\n"
"#endif\n"
"\n"
"    for (uint i=0; i<valence; ++i) {\n"
"        uint im=(i+valence-1)%valence; \n"
"        uint ip=(i+1)%valence; \n"
"\n"
"        uint idx_neighbor = uint(OsdValenceBuffer[int(vID * (2*OSD_MAX_VALENCE+1) + 2*i + 0 + 1)]);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"        bool isBoundaryNeighbor = false;\n"
"        int valenceNeighbor = OsdValenceBuffer[int(idx_neighbor * (2*OSD_MAX_VALENCE+1))];\n"
"\n"
"        if (valenceNeighbor < 0) {\n"
"            isBoundaryNeighbor = true;\n"
"            boundaryEdgeNeighbors[currNeighbor++] = int(idx_neighbor);\n"
"            if (currNeighbor == 1)    {\n"
"                ibefore = i;\n"
"                zerothNeighbor = i;\n"
"            } else {\n"
"                if (i-ibefore == 1) {\n"
"                    int tmp = boundaryEdgeNeighbors[0];\n"
"                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];\n"
"                    boundaryEdgeNeighbors[1] = tmp;\n"
"                    zerothNeighbor = i;\n"
"                } \n"
"            }\n"
"        }\n"
"#endif\n"
"\n"
"        float3 neighbor =\n"
"            float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor+1)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor+2)]);\n"
"\n"
"        uint idx_diagonal = uint(OsdValenceBuffer[int(vID * (2*OSD_MAX_VALENCE+1) + 2*i + 1 + 1)]);\n"
"\n"
"        float3 diagonal =\n"
"            float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal+1)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal+2)]);\n"
"\n"
"        uint idx_neighbor_p = uint(OsdValenceBuffer[int(vID * (2*OSD_MAX_VALENCE+1) + 2*ip + 0 + 1)]);\n"
"\n"
"        float3 neighbor_p =\n"
"            float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor_p)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor_p+1)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor_p+2)]);\n"
"\n"
"        uint idx_neighbor_m = uint(OsdValenceBuffer[int(vID * (2*OSD_MAX_VALENCE+1) + 2*im + 0 + 1)]);\n"
"\n"
"        float3 neighbor_m =\n"
"            float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor_m)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor_m+1)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor_m+2)]);\n"
"\n"
"        uint idx_diagonal_m = uint(OsdValenceBuffer[int(vID * (2*OSD_MAX_VALENCE+1) + 2*im + 1 + 1)]);\n"
"\n"
"        float3 diagonal_m =\n"
"            float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal_m)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal_m+1)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal_m+2)]);\n"
"\n"
"        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);\n"
"\n"
"        opos += f[i];\n"
"        output.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;\n"
"    }\n"
"\n"
"    opos /= valence;\n"
"    output.position = float4(opos, 1.0f).xyz;\n"
"\n"
"    float3 e;\n"
"    output.e0 = float3(0,0,0);\n"
"    output.e1 = float3(0,0,0);\n"
"\n"
"    for(uint i=0; i<valence; ++i) {\n"
"        uint im = (i + valence -1) % valence;\n"
"        e = 0.5f * (f[i] + f[im]);\n"
"        output.e0 += csf(valence-3, 2*i) *e;\n"
"        output.e1 += csf(valence-3, 2*i + 1)*e;\n"
"    }\n"
"    output.e0 *= ef[valence - 3];\n"
"    output.e1 *= ef[valence - 3];\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    output.zerothNeighbor = zerothNeighbor;\n"
"    if (currNeighbor == 1) {\n"
"        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];\n"
"    }\n"
"\n"
"    if (ivalence < 0) {\n"
"        if (valence > 2) {\n"
"            output.position = (\n"
"                float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0])],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+1)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+2)]) +\n"
"                float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1])],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+1)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+2)]) +\n"
"                4.0f * pos)/6.0f;        \n"
"        } else {\n"
"            output.position = pos;                    \n"
"        }\n"
"\n"
"        output.e0 = ( \n"
"            float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0])],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+1)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+2)]) -\n"
"            float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1])],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+1)],\n"
"                   OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+2)]) \n"
"            )/6.0;\n"
"\n"
"        float k = float(float(valence) - 1.0f);    //k is the number of faces\n"
"        float c = cos(M_PI/k);\n"
"        float s = sin(M_PI/k);\n"
"        float gamma = -(4.0f*s)/(3.0f*k+c);\n"
"        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));\n"
"        float beta_0 = s/(3.0f*k + c); \n"
"\n"
"\n"
"        int idx_diagonal = OsdValenceBuffer[int((vID) * (2*OSD_MAX_VALENCE+1) + 2*zerothNeighbor + 1 + 1)];\n"
"        idx_diagonal = abs(idx_diagonal);\n"
"        float3 diagonal =\n"
"                float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal+1)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal+2)]);\n"
"\n"
"        output.e1 = gamma * pos + \n"
"            alpha_0k * float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0])],\n"
"                              OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+1)],\n"
"                              OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+2)]) +\n"
"            alpha_0k * float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1])],\n"
"                              OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+1)],\n"
"                              OsdVertexBuffer[int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+2)]) +\n"
"            beta_0 * diagonal;\n"
"\n"
"        for (uint x=1; x<valence - 1; ++x) {\n"
"            uint curri = ((x + zerothNeighbor)%valence);\n"
"            float alpha = (4.0f*sin((M_PI * float(x))/k))/(3.0f*k+c);\n"
"            float beta = (sin((M_PI * float(x))/k) + sin((M_PI * float(x+1))/k))/(3.0f*k+c);\n"
"\n"
"            int idx_neighbor = OsdValenceBuffer[int((vID) * (2*OSD_MAX_VALENCE+1) + 2*curri + 0 + 1)];\n"
"            idx_neighbor = abs(idx_neighbor);\n"
"\n"
"            float3 neighbor =\n"
"                float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor+1)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_neighbor+2)]);\n"
"\n"
"            idx_diagonal = OsdValenceBuffer[int((vID) * (2*OSD_MAX_VALENCE+1) + 2*curri + 1 + 1)];\n"
"\n"
"            diagonal =\n"
"                float3(OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal+1)],\n"
"                       OsdVertexBuffer[int(OSD_NUM_ELEMENTS*idx_diagonal+2)]);\n"
"\n"
"            output.e1 += alpha * neighbor + beta * diagonal;                         \n"
"        }\n"
"\n"
"        output.e1 /= 3.0f;\n"
"    } \n"
"#endif\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.HullGregory\n"
"//----------------------------------------------------------\n"
"\n"
"Buffer<int> OsdQuadOffsetBuffer : register( t2 );\n"
"\n"
"HS_CONSTANT_FUNC_OUT HSConstFunc(\n"
"    InputPatch<GregHullVertex, 4> patch,\n"
"    uint primitiveID : SV_PrimitiveID)\n"
"{\n"
"    HS_CONSTANT_FUNC_OUT output;\n"
"    int patchLevel = GetPatchLevel(primitiveID);\n"
"\n"
"    OSD_PATCH_CULL(4);\n"
"\n"
"#ifdef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    output.tessLevelOuter[0] =\n"
"        TessAdaptive(patch[0].hullPosition.xyz, patch[1].hullPosition.xyz);\n"
"    output.tessLevelOuter[1] =\n"
"        TessAdaptive(patch[0].hullPosition.xyz, patch[3].hullPosition.xyz);\n"
"    output.tessLevelOuter[2] =\n"
"        TessAdaptive(patch[2].hullPosition.xyz, patch[3].hullPosition.xyz);\n"
"    output.tessLevelOuter[3] =\n"
"        TessAdaptive(patch[1].hullPosition.xyz, patch[2].hullPosition.xyz);\n"
"    output.tessLevelInner[0] =\n"
"        max(output.tessLevelOuter[1], output.tessLevelOuter[3]);\n"
"    output.tessLevelInner[1] =\n"
"        max(output.tessLevelOuter[0], output.tessLevelOuter[2]);\n"
"#else\n"
"    output.tessLevelInner[0] = GetTessLevel(patchLevel);\n"
"    output.tessLevelInner[1] = GetTessLevel(patchLevel);\n"
"    output.tessLevelOuter[0] = GetTessLevel(patchLevel);\n"
"    output.tessLevelOuter[1] = GetTessLevel(patchLevel);\n"
"    output.tessLevelOuter[2] = GetTessLevel(patchLevel);\n"
"    output.tessLevelOuter[3] = GetTessLevel(patchLevel);\n"
"#endif\n"
"    return output;\n"
"}\n"
"\n"
"[domain(\"quad\")]\n"
"[partitioning(HS_PARTITION)]\n"
"[outputtopology(\"triangle_ccw\")]\n"
"[outputcontrolpoints(4)]\n"
"[patchconstantfunc(\"HSConstFunc\")]\n"
"GregDomainVertex hs_main_patches(\n"
"    in InputPatch<GregHullVertex, 4> patch,\n"
"    uint primitiveID : SV_PrimitiveID,\n"
"    in uint ID : SV_OutputControlPointID )\n"
"{\n"
"    uint i = ID;\n"
"    uint ip = (i+1)%4;\n"
"    uint im = (i+3)%4;\n"
"    uint valence = abs(patch[i].valence);\n"
"    uint n = valence;\n"
"    int base = GregoryQuadOffsetBase;\n"
"\n"
"    GregDomainVertex output;\n"
"    output.position = patch[ID].position;\n"
"\n"
"    uint start = uint(OsdQuadOffsetBuffer[int(4*primitiveID+base + i)]) & 0x00ffu;\n"
"    uint prev = uint(OsdQuadOffsetBuffer[int(4*primitiveID+base + i)]) & 0xff00u;\n"
"    prev = uint(prev/256);\n"
"\n"
"    uint start_m = uint(OsdQuadOffsetBuffer[int(4*primitiveID+base + im)]) & 0x00ffu;\n"
"    uint prev_p = uint(OsdQuadOffsetBuffer[int(4*primitiveID+base + ip)]) & 0xff00u;\n"
"    prev_p = uint(prev_p/256);\n"
"\n"
"    uint np = abs(patch[ip].valence);\n"
"    uint nm = abs(patch[im].valence);\n"
"\n"
"    // Control Vertices based on : \n"
"    // \"Approximating Subdivision Surfaces with Gregory Patches for Hardware Tessellation\" \n"
"    // Loop, Schaefer, Ni, Castafio (ACM ToG Siggraph Asia 2009)\n"
"    //\n"
"    //  P3         e3-      e2+         E2\n"
"    //     O--------O--------O--------O\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |        O        O        |\n"
"    // e3+ O------O            O------O e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- O------O            O------O e1+\n"
"    //     |        O        O        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------O--------O--------O\n"
"    //  P0         e0+      e1-         E1\n"
"    //\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    float3 Ep = float3(0.0f,0.0f,0.0f);\n"
"    float3 Em = float3(0.0f,0.0f,0.0f);\n"
"    float3 Fp = float3(0.0f,0.0f,0.0f);\n"
"    float3 Fm = float3(0.0f,0.0f,0.0f);\n"
"\n"
"    float3 Em_ip;\n"
"    if (patch[ip].valence < -2) {\n"
"        uint j = (np + prev_p - patch[ip].zerothNeighbor) % np;\n"
"        Em_ip = patch[ip].position + cos((M_PI*j)/float(np-1))*patch[ip].e0 + sin((M_PI*j)/float(np-1))*patch[ip].e1;\n"
"    } else {\n"
"        Em_ip = patch[ip].position + patch[ip].e0*csf(np-3, 2*prev_p) + patch[ip].e1*csf(np-3, 2*prev_p + 1);\n"
"    }\n"
"\n"
"    float3 Ep_im;\n"
"    if (patch[im].valence < -2) {\n"
"        uint j = (nm + start_m - patch[im].zerothNeighbor) % nm;\n"
"        Ep_im = patch[im].position + cos((M_PI*j)/float(nm-1))*patch[im].e0 + sin((M_PI*j)/float(nm-1))*patch[im].e1;\n"
"    } else {\n"
"        Ep_im = patch[im].position + patch[im].e0*csf(nm-3, 2*start_m) + patch[im].e1*csf(nm-3, 2*start_m + 1);\n"
"    }\n"
"\n"
"    if (patch[i].valence < 0) {\n"
"        n = (n-1)*2;\n"
"    }\n"
"    if (patch[im].valence < 0) {\n"
"        nm = (nm-1)*2;\n"
"    }  \n"
"    if (patch[ip].valence < 0) {\n"
"        np = (np-1)*2;\n"
"    }\n"
"\n"
"    if (patch[i].valence > 2) {\n"
"        Ep = patch[i].position + (patch[i].e0*csf(n-3, 2*start) + patch[i].e1*csf(n-3, 2*start + 1));\n"
"        Em = patch[i].position + (patch[i].e0*csf(n-3, 2*prev) +  patch[i].e1*csf(n-3, 2*prev + 1)); \n"
"\n"
"        float s1=3-2*csf(n-3,2)-csf(np-3,2);\n"
"        float s2=2*csf(n-3,2);\n"
"\n"
"        Fp = (csf(np-3,2)*patch[i].position + s1*Ep + s2*Em_ip + patch[i].r[start])/3.0f; \n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        Fm = (csf(nm-3,2)*patch[i].position + s1*Em + s2*Ep_im - patch[i].r[prev])/3.0f;\n"
"\n"
"    } else if (patch[i].valence < -2) {\n"
"        uint j = (valence + start - patch[i].zerothNeighbor) % valence;\n"
"\n"
"        Ep = patch[i].position + cos((M_PI*j)/float(valence-1))*patch[i].e0 + sin((M_PI*j)/float(valence-1))*patch[i].e1;\n"
"        j = (valence + prev - patch[i].zerothNeighbor) % valence;\n"
"        Em = patch[i].position + cos((M_PI*j)/float(valence-1))*patch[i].e0 + sin((M_PI*j)/float(valence-1))*patch[i].e1;\n"
"\n"
"        float3 Rp = ((-2.0f * patch[i].org - 1.0f * patch[im].org) + (2.0f * patch[ip].org + 1.0f * patch[(i+2)%4].org))/3.0f;\n"
"        float3 Rm = ((-2.0f * patch[i].org - 1.0f * patch[ip].org) + (2.0f * patch[im].org + 1.0f * patch[(i+2)%4].org))/3.0f;\n"
"\n"
"        float s1 = 3-2*csf(n-3,2)-csf(np-3,2);\n"
"        float s2 = 2*csf(n-3,2);\n"
"\n"
"        Fp = (csf(np-3,2)*patch[i].position + s1*Ep + s2*Em_ip + patch[i].r[start])/3.0f; \n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        Fm = (csf(nm-3,2)*patch[i].position + s1*Em + s2*Ep_im - patch[i].r[prev])/3.0f;\n"
"\n"
"        if (patch[im].valence < 0) {\n"
"            s1=3-2*csf(n-3,2)-csf(np-3,2);\n"
"            Fp = Fm = (csf(np-3,2)*patch[i].position + s1*Ep + s2*Em_ip + patch[i].r[start])/3.0f;\n"
"        } else if (patch[ip].valence < 0) {\n"
"            s1 = 3.0f-2.0f*cos(2.0f*M_PI/n)-cos(2.0f*M_PI/nm);\n"
"            Fm = Fp = (csf(nm-3,2)*patch[i].position + s1*Em + s2*Ep_im - patch[i].r[prev])/3.0f;\n"
"        }\n"
"\n"
"    } else if (patch[i].valence == -2) {\n"
"        Ep = (2.0f * patch[i].org + patch[ip].org)/3.0f;\n"
"        Em = (2.0f * patch[i].org + patch[im].org)/3.0f;\n"
"        Fp = Fm = (4.0f * patch[i].org + patch[(i+2)%n].org + 2.0f * patch[ip].org + 2.0f * patch[im].org)/9.0f;\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"    float3 Ep = patch[i].position + patch[i].e0 * csf(n-3, 2*start) + patch[i].e1*csf(n-3, 2*start + 1);\n"
"    float3 Em = patch[i].position + patch[i].e0 * csf(n-3, 2*prev ) + patch[i].e1*csf(n-3, 2*prev + 1);\n"
"\n"
"    float3 Em_ip = patch[ip].position + patch[ip].e0*csf(np-3, 2*prev_p) + patch[ip].e1*csf(np-3, 2*prev_p + 1);\n"
"    float3 Ep_im = patch[im].position + patch[im].e0*csf(nm-3, 2*start_m) + patch[im].e1*csf(nm-3, 2*start_m + 1);\n"
"\n"
"    float s1 = 3-2*csf(n-3,2)-csf(np-3,2);\n"
"    float s2 = 2*csf(n-3,2);\n"
"\n"
"    float3 Fp = (csf(np-3,2)*patch[i].position + s1*Ep + s2*Em_ip + patch[i].r[start])/3.0f;\n"
"    s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"    float3 Fm = (csf(nm-3,2)*patch[i].position + s1*Em +s2*Ep_im - patch[i].r[prev])/3.0f;\n"
"\n"
"#endif\n"
"\n"
"    output.Ep = Ep;\n"
"    output.Em = Em;\n"
"    output.Fp = Fp;\n"
"    output.Fm = Fm;\n"
"\n"
"    int patchLevel = GetPatchLevel(primitiveID);\n"
"    output.patchCoord = float4(0, 0,\n"
"                               patchLevel+0.5f,\n"
"                               primitiveID+PrimitiveIdBase+0.5f);\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_HULL_SHADER;\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.DomainGregory\n"
"//----------------------------------------------------------\n"
"\n"
"[domain(\"quad\")]\n"
"void ds_main_patches(\n"
"    in HS_CONSTANT_FUNC_OUT input,\n"
"    in OutputPatch<GregDomainVertex, 4> patch,\n"
"    in float2 uv : SV_DomainLocation,\n"
"    out OutputVertex output )\n"
"{\n"
"    float u = uv.x,\n"
"          v = uv.y;\n"
"\n"
"    float3 p[20];\n"
"\n"
"    p[0] = patch[0].position;\n"
"    p[1] = patch[0].Ep;\n"
"    p[2] = patch[0].Em;\n"
"    p[3] = patch[0].Fp;\n"
"    p[4] = patch[0].Fm;\n"
"\n"
"    p[5] = patch[1].position;\n"
"    p[6] = patch[1].Ep;\n"
"    p[7] = patch[1].Em;\n"
"    p[8] = patch[1].Fp;\n"
"    p[9] = patch[1].Fm;\n"
"\n"
"    p[10] = patch[2].position;\n"
"    p[11] = patch[2].Ep;\n"
"    p[12] = patch[2].Em;\n"
"    p[13] = patch[2].Fp;\n"
"    p[14] = patch[2].Fm;\n"
"\n"
"    p[15] = patch[3].position;\n"
"    p[16] = patch[3].Ep;\n"
"    p[17] = patch[3].Em;\n"
"    p[18] = patch[3].Fp;\n"
"    p[19] = patch[3].Fm;\n"
"\n"
"    float3 q[16];\n"
"\n"
"    float U = 1-u, V=1-v;\n"
"\n"
"    float d11 = u+v; if(u+v==0.0f) d11 = 1.0f;\n"
"    float d12 = U+v; if(U+v==0.0f) d12 = 1.0f;\n"
"    float d21 = u+V; if(u+V==0.0f) d21 = 1.0f;\n"
"    float d22 = U+V; if(U+V==0.0f) d22 = 1.0f;\n"
"\n"
"    q[ 5] = (u*p[3] + v*p[4])/d11;\n"
"    q[ 6] = (U*p[9] + v*p[8])/d12;\n"
"    q[ 9] = (u*p[19] + V*p[18])/d21;\n"
"    q[10] = (U*p[13] + V*p[14])/d22;\n"
"\n"
"    q[ 0] = p[0];\n"
"    q[ 1] = p[1];\n"
"    q[ 2] = p[7];\n"
"    q[ 3] = p[5];\n"
"    q[ 4] = p[2];\n"
"    q[ 7] = p[6];\n"
"    q[ 8] = p[16];\n"
"    q[11] = p[12];\n"
"    q[12] = p[15];\n"
"    q[13] = p[17];\n"
"    q[14] = p[11];\n"
"    q[15] = p[10];\n"
"\n"
"    float3 WorldPos  = float3(0, 0, 0);\n"
"    float3 Tangent   = float3(0, 0, 0);\n"
"    float3 BiTangent = float3(0, 0, 0);\n"
"\n"
"#line 519\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    float B[4], D[4], C[4];\n"
"    float3 BUCP[4], DUCP[4], CUCP[4];\n"
"    float3 dUU = float3(0, 0, 0);\n"
"    float3 dVV = float3(0, 0, 0);\n"
"    float3 dUV = float3(0, 0, 0);\n"
"\n"
"    Univar4x4(u, B, D, C);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        BUCP[i] = float3(0, 0, 0);\n"
"        DUCP[i] = float3(0, 0, 0);\n"
"        CUCP[i] = float3(0, 0, 0);\n"
"\n"
"        for (uint j=0; j<4; ++j) {\n"
"            // reverse face front\n"
"            float3 A = q[i + 4*j];\n"
"\n"
"            BUCP[i] += A * B[j];\n"
"            DUCP[i] += A * D[j];\n"
"            CUCP[i] += A * C[j];\n"
"        }\n"
"    }\n"
"\n"
"    Univar4x4(v, B, D, C);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        WorldPos  += B[i] * BUCP[i];\n"
"        Tangent   += B[i] * DUCP[i];\n"
"        BiTangent += D[i] * BUCP[i];\n"
"        dUU += B[i] * CUCP[i];\n"
"        dVV += C[i] * BUCP[i];\n"
"        dUV += D[i] * DUCP[i];\n"
"    }\n"
"\n"
"    int level = int(patch[0].ptexInfo.z);\n"
"    BiTangent *= 3 * level;\n"
"    Tangent *= 3 * level;\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    float3 n = cross(Tangent, BiTangent);\n"
"    float3 normal = normalize(n);\n"
"\n"
"    float E = dot(Tangent, Tangent);\n"
"    float F = dot(Tangent, BiTangent);\n"
"    float G = dot(BiTangent, BiTangent);\n"
"    float e = dot(normal, dUU);\n"
"    float f = dot(normal, dUV);\n"
"    float g = dot(normal, dVV);\n"
"\n"
"    float3 Nu = (f*F-e*G)/(E*G-F*F) * Tangent + (e*F-f*E)/(E*G-F*F) * BiTangent;\n"
"    float3 Nv = (g*F-f*G)/(E*G-F*F) * Tangent + (f*F-g*E)/(E*G-F*F) * BiTangent;\n"
"\n"
"    Nu = Nu/length(n) - n * (dot(Nu,n)/pow(dot(n,n), 1.5));\n"
"    Nv = Nv/length(n) - n * (dot(Nv,n)/pow(dot(n,n), 1.5));\n"
"\n"
"    BiTangent = mul(ModelViewMatrix, float4(BiTangent, 0)).xyz;\n"
"    Tangent = mul(ModelViewMatrix, float4(Tangent, 0)).xyz;\n"
"\n"
"    normal = normalize(cross(BiTangent, Tangent));\n"
"\n"
"    output.Nu = Nu;\n"
"    output.Nv = Nv;\n"
"\n"
"#else\n"
"    float B[4], D[4];\n"
"    float3 BUCP[4], DUCP[4];\n"
"\n"
"    Univar4x4(uv.x, B, D);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        BUCP[i] =  float3(0, 0, 0);\n"
"        DUCP[i] =  float3(0, 0, 0);\n"
"\n"
"        for (uint j=0; j<4; ++j) {\n"
"            // reverse face front\n"
"            float3 A = q[i + 4*j];\n"
"\n"
"            BUCP[i] += A * B[j];\n"
"            DUCP[i] += A * D[j];\n"
"        }\n"
"    }\n"
"\n"
"    Univar4x4(uv.y, B, D);\n"
"\n"
"    for (uint i=0; i<4; ++i) {\n"
"        WorldPos  += B[i] * BUCP[i];\n"
"        Tangent   += B[i] * DUCP[i];\n"
"        BiTangent += D[i] * BUCP[i];\n"
"    }\n"
"    int level = int(patch[0].ptexInfo.z);\n"
"    BiTangent *= 3 * level;\n"
"    Tangent *= 3 * level;\n"
"\n"
"    BiTangent = mul(ModelViewMatrix, float4(BiTangent, 0)).xyz;\n"
"    Tangent = mul(ModelViewMatrix, float4(Tangent, 0)).xyz;\n"
"\n"
"    float3 normal = normalize(cross(BiTangent, Tangent));\n"
"\n"
"#endif\n"
"\n"
"    output.position = mul(ModelViewMatrix, float4(WorldPos, 1.0f));\n"
"    output.normal = normal;\n"
"    output.tangent = BiTangent;\n"
"    output.bitangent = Tangent;\n"
"\n"
"    output.patchCoord = patch[0].patchCoord;\n"
"    output.patchCoord.xy = float2(v, u);\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_DOMAIN_SHADER;\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    output.positionOut = mul(ProjectionMatrix,\n"
"                             float4(output.position.xyz, 1.0f));\n"
"}\n"
"\n"
