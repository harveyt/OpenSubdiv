"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Common\n"
"//----------------------------------------------------------\n"
"\n"
"#ifndef OSD_USER_VARYING_DECLARE\n"
"#define OSD_USER_VARYING_DECLARE\n"
"// type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"#define OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"// layout(location = loc) in type var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_VERTEX\n"
"#define OSD_USER_VARYING_PER_VERTEX()\n"
"// output.var = var;\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_CONTROL_POINT\n"
"#define OSD_USER_VARYING_PER_CONTROL_POINT(ID_OUT, ID_IN)\n"
"// output[ID_OUT].var = input[ID_IN].var\n"
"#endif\n"
"\n"
"#ifndef OSD_USER_VARYING_PER_EVAL_POINT\n"
"#define OSD_USER_VARYING_PER_EVAL_POINT(UV, a, b, c, d)\n"
"// output.var =\n"
"//     mix(mix(input[a].var, input[b].var, UV.x),\n"
"//         mix(input[c].var, input[d].var, UV.x), UV.y)\n"
"#endif\n"
"\n"
"#ifndef OSD_TRANSITION_ROTATE\n"
"#define OSD_TRANSITION_ROTATE 0\n"
"#endif\n"
"\n"
"#if defined OSD_PATCH_BOUNDARY\n"
"    #define OSD_PATCH_INPUT_SIZE 12\n"
"#elif defined OSD_PATCH_CORNER\n"
"    #define OSD_PATCH_INPUT_SIZE 9\n"
"#else\n"
"    #define OSD_PATCH_INPUT_SIZE 16\n"
"#endif\n"
"\n"
"#define M_PI 3.14159265359f\n"
"\n"
"#if __VERSION__ < 420\n"
"    #define centroid\n"
"#endif\n"
"\n"
"struct ControlVertex {\n"
"    vec4 position;\n"
"    centroid vec4 patchCoord; // u, v, level, faceID\n"
"    ivec4 ptexInfo;  // U offset, V offset, 2^ptexlevel', rotation\n"
"    ivec3 clipFlag;\n"
"};\n"
"\n"
"struct OutputVertex {\n"
"    vec4 position;\n"
"    vec3 normal;\n"
"    centroid vec4 patchCoord; // u, v, level, faceID\n"
"    centroid vec2 tessCoord; // tesscoord.st\n"
"    vec3 tangent;\n"
"    vec3 bitangent;\n"
"#if defined OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    vec3 Nu;\n"
"    vec3 Nv;\n"
"#endif\n"
"};\n"
"\n"
"struct GregControlVertex {\n"
"    vec3 position;\n"
"    vec3 hullPosition;\n"
"    ivec3 clipFlag;\n"
"    int  valence;\n"
"    vec3 e0;\n"
"    vec3 e1;\n"
"    uint zerothNeighbor;\n"
"    vec3 org;\n"
"#if OSD_MAX_VALENCE > 0\n"
"    vec3 r[OSD_MAX_VALENCE];\n"
"#endif\n"
"};\n"
"\n"
"struct GregEvalVertex {\n"
"    vec3 position;\n"
"    vec3 Ep;\n"
"    vec3 Em;\n"
"    vec3 Fp;\n"
"    vec3 Fm;\n"
"    centroid vec4 patchCoord;\n"
"    ivec4 ptexInfo;\n"
"};\n"
"\n"
"layout(std140) uniform Transform {\n"
"    mat4 ModelViewMatrix;\n"
"    mat4 ProjectionMatrix;\n"
"    mat4 ModelViewProjectionMatrix;\n"
"    mat4 ModelViewInverseMatrix;\n"
"#ifdef OSD_USER_TRANSFORM_UNIFORMS\n"
"    OSD_USER_TRANSFORM_UNIFORMS\n"
"#endif\n"
"};\n"
"\n"
"layout(std140) uniform Tessellation {\n"
"    float TessLevel;\n"
"};\n"
"\n"
"uniform int OsdGregoryQuadOffsetBase;\n"
"uniform int OsdPrimitiveIdBase;\n"
"\n"
"float GetTessLevel(int patchLevel)\n"
"{\n"
"#ifdef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    return TessLevel;\n"
"#else\n"
"    return TessLevel / pow(2, patchLevel-1);\n"
"#endif\n"
"}\n"
"\n"
"float GetPostProjectionSphereExtent(vec3 center, float diameter)\n"
"{\n"
"    vec4 p = ProjectionMatrix * vec4(center, 1.0);\n"
"    return abs(diameter * ProjectionMatrix[1][1] / p.w);\n"
"}\n"
"\n"
"float TessAdaptive(vec3 p0, vec3 p1)\n"
"{\n"
"    // Adaptive factor can be any computation that depends only on arg values.\n"
"    // Project the diameter of the edge's bounding sphere instead of using the\n"
"    // length of the projected edge itself to avoid problems near silhouettes.\n"
"    vec3 center = (p0 + p1) / 2.0;\n"
"    float diameter = distance(p0, p1);\n"
"    return max(1.0, TessLevel * GetPostProjectionSphereExtent(center, diameter));\n"
"}\n"
"\n"
"#ifndef OSD_DISPLACEMENT_CALLBACK\n"
"#define OSD_DISPLACEMENT_CALLBACK\n"
"#endif\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// ptex coordinates\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"uniform isamplerBuffer OsdPatchParamBuffer;\n"
"\n"
"#define GetPatchLevel()                                                 "
"        (texelFetch(OsdPatchParamBuffer, gl_PrimitiveID +               "
"                                         OsdPrimitiveIdBase).y & 0xf)\n"
"\n"
"#define OSD_COMPUTE_PTEX_COORD_TESSCONTROL_SHADER                       "
"    {                                                                   "
"        ivec2 ptexIndex = texelFetch(OsdPatchParamBuffer,               "
"                                     gl_PrimitiveID +                   "
"                                     OsdPrimitiveIdBase).xy;            "
"        int faceID = ptexIndex.x;                                       "
"        int lv = 1 << ((ptexIndex.y & 0xf) - ((ptexIndex.y >> 4) & 1)); "
"        int u = (ptexIndex.y >> 17) & 0x3ff;                            "
"        int v = (ptexIndex.y >> 7) & 0x3ff;                             "
"        int rotation = (ptexIndex.y >> 5) & 0x3;                        "
"        outpt[ID].v.patchCoord.w = faceID+0.5;                          "
"        outpt[ID].v.ptexInfo = ivec4(u, v, lv, rotation);               "
"    }\n"
"\n"
"#define OSD_COMPUTE_PTEX_COORD_TESSEVAL_SHADER                          "
"    {                                                                   "
"        vec2 uv = outpt.v.patchCoord.xy;                                "
"        ivec2 p = inpt[0].v.ptexInfo.xy;                                "
"        int lv = inpt[0].v.ptexInfo.z;                                  "
"        int rot = inpt[0].v.ptexInfo.w;                                 "
"        outpt.v.tessCoord.xy = uv;                                      "
"        uv.xy = float(rot==0)*uv.xy                                     "
"            + float(rot==1)*vec2(1.0-uv.y, uv.x)                        "
"            + float(rot==2)*vec2(1.0-uv.x, 1.0-uv.y)                    "
"            + float(rot==3)*vec2(uv.y, 1.0-uv.x);                       "
"        outpt.v.patchCoord.xy = (uv * vec2(1.0)/lv) + vec2(p.x, p.y)/lv; "
"    }\n"
"\n"
"#define OSD_COMPUTE_PTEX_COMPATIBLE_TANGENT(ROTATE)                 "
"    {                                                               "
"        int rot = (inpt[0].v.ptexInfo.w + 4 - ROTATE)%4;            "
"        if (rot == 1) {                                             "
"            outpt.v.tangent = -BiTangent;                           "
"            outpt.v.bitangent = Tangent;                            "
"        } else if (rot == 2) {                                      "
"            outpt.v.tangent = -Tangent;                             "
"            outpt.v.bitangent = -BiTangent;                         "
"        } else if (rot == 3) {                                      "
"            outpt.v.tangent = BiTangent;                            "
"            outpt.v.bitangent = -Tangent;                           "
"        } else {                                                    "
"            outpt.v.tangent = Tangent;                              "
"            outpt.v.bitangent = BiTangent;                          "
"        }                                                           "
"    }\n"
"\n"
"#define OSD_COMPUTE_PTEX_COMPATIBLE_DERIVATIVES(ROTATE)             "
"    {                                                               "
"        int rot = (inpt[0].v.ptexInfo.w + 4 - ROTATE)%4;            "
"        if (rot == 1) {                                             "
"            outpt.v.tangent = -BiTangent;                           "
"            outpt.v.bitangent = Tangent;                            "
"            outpt.v.Nu = -Nv;                                       "
"            outpt.v.Nv = Nv;                                        "
"        } else if (rot == 2) {                                      "
"            outpt.v.tangent = -Tangent;                             "
"            outpt.v.bitangent = -BiTangent;                         "
"            outpt.v.Nu = -Nu;                                       "
"            outpt.v.Nv = -Nv;                                       "
"        } else if (rot == 3) {                                      "
"            outpt.v.tangent = BiTangent;                            "
"            outpt.v.bitangent = -Tangent;                           "
"            outpt.v.Nu = Nv;                                        "
"            outpt.v.Nv = -Nu;                                       "
"        } else {                                                    "
"            outpt.v.tangent = Tangent;                              "
"            outpt.v.bitangent = BiTangent;                          "
"            outpt.v.Nu = Nu;                                        "
"            outpt.v.Nv = Nv;                                        "
"        }                                                           "
"    }\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// face varyings\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"uniform samplerBuffer OsdFVarDataBuffer;\n"
"\n"
"#ifndef OSD_FVAR_WIDTH\n"
"#define OSD_FVAR_WIDTH 0\n"
"#endif\n"
"\n"
"// ------ extract from quads (catmark, bilinear) ---------\n"
"// XXX: only linear interpolation is supported\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_1(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        float v[4];                                                     "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 4;     "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = texelFetch(OsdFVarDataBuffer, index).s               "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_2(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec2 v[4];                                                      "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 4;     "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec2(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_3(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec3 v[4];                                                      "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 4;     "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec3(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_4(result, fvarOffset, tessCoord)       "
"    {                                                                   "
"        vec4 v[4];                                                      "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 4;     "
"        for (int i = 0; i < 4; ++i) {                                   "
"            int index = (primOffset+i)*OSD_FVAR_WIDTH + fvarOffset;     "
"            v[i] = vec4(texelFetch(OsdFVarDataBuffer, index).s,         "
"                        texelFetch(OsdFVarDataBuffer, index + 1).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 2).s,     "
"                        texelFetch(OsdFVarDataBuffer, index + 3).s);    "
"        }                                                               "
"        result = mix(mix(v[0], v[1], tessCoord.s),                      "
"                     mix(v[3], v[2], tessCoord.s),                      "
"                     tessCoord.t);                                      "
"    }\n"
"\n"
"// ------ extract from triangles (loop) ---------\n"
"// XXX: no interpolation supproted\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_1(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 3;     "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = texelFetch(OsdFVarDataBuffer, index).s;                "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_2(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 3;     "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec2(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_3(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 3;     "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec3(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s);      "
"    }\n"
"\n"
"#define OSD_COMPUTE_FACE_VARYING_TRI_4(result, fvarOffset, triVert)     "
"    {                                                                   "
"        int primOffset = (gl_PrimitiveID + OsdPrimitiveIdBase) * 3;     "
"        int index = (primOffset+triVert)*OSD_FVAR_WIDTH + fvarOffset;   "
"        result = vec4(texelFetch(OsdFVarDataBuffer, index).s,           "
"                      texelFetch(OsdFVarDataBuffer, index + 1).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 2).s,       "
"                      texelFetch(OsdFVarDataBuffer, index + 3).s);      "
"    }\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"// patch culling\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)                     "
"    vec4 clipPos = ModelViewProjectionMatrix * P;               "
"    bvec3 clip0 = lessThan(clipPos.xyz, vec3(clipPos.w));       "
"    bvec3 clip1 = greaterThan(clipPos.xyz, -vec3(clipPos.w));   "
"    outpt.v.clipFlag = ivec3(clip0) + 2*ivec3(clip1);           "
"\n"
"#define OSD_PATCH_CULL(N)                            "
"    ivec3 clipFlag = ivec3(0);                       "
"    for(int i = 0; i < N; ++i) {                     "
"        clipFlag |= inpt[i].v.clipFlag;              "
"    }                                                "
"    if (clipFlag != ivec3(3) ) {                     "
"        gl_TessLevelInner[0] = 0;                    "
"        gl_TessLevelInner[1] = 0;                    "
"        gl_TessLevelOuter[0] = 0;                    "
"        gl_TessLevelOuter[1] = 0;                    "
"        gl_TessLevelOuter[2] = 0;                    "
"        gl_TessLevelOuter[3] = 0;                    "
"        return;                                      "
"    }\n"
"\n"
"#else\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)\n"
"#define OSD_PATCH_CULL(N)\n"
"#endif\n"
"\n"
"// ----------------------------------------------------------------------------\n"
"\n"
"void\n"
"Univar4x4(in float u, out float B[4], out float D[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"}\n"
"\n"
"void\n"
"Univar4x4(in float u, out float B[4], out float D[4], out float C[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"\n"
"    A0 =   - s;\n"
"    A1 = s - t;\n"
"    A2 = t;\n"
"\n"
"    C[0] =    - A0;\n"
"    C[1] = A0 - A1;\n"
"    C[2] = A1 - A2;\n"
"    C[3] = A2;\n"
"}\n"
"\n"
