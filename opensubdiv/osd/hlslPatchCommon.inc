"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Common\n"
"//----------------------------------------------------------\n"
"\n"
"#ifndef OSD_TRANSITION_ROTATE\n"
"#define OSD_TRANSITION_ROTATE 0\n"
"#endif\n"
"\n"
"#if defined OSD_PATCH_BOUNDARY\n"
"    #define OSD_PATCH_INPUT_SIZE 12\n"
"#elif defined OSD_PATCH_CORNER\n"
"    #define OSD_PATCH_INPUT_SIZE 9\n"
"#else\n"
"    #define OSD_PATCH_INPUT_SIZE 16\n"
"#endif\n"
"\n"
"#define M_PI 3.14159265359f\n"
"\n"
"struct InputVertex {\n"
"    float4 position : POSITION;\n"
"    float3 normal : NORMAL;\n"
"};\n"
"\n"
"struct HullVertex {\n"
"    float4 position : POSITION;\n"
"    float4 patchCoord : PATCHCOORD; // u, v, level, faceID\n"
"    int4 ptexInfo : PTEXINFO;       // u offset, v offset, 2^ptexlevel, rotation\n"
"    int3 clipFlag : CLIPFLAG;\n"
"};\n"
"\n"
"struct OutputVertex {\n"
"    float4 positionOut : SV_Position;\n"
"    float4 position : POSITION1;\n"
"    float3 normal : NORMAL;\n"
"    float3 tangent : TANGENT0;\n"
"    float3 bitangent : TANGENT1;\n"
"    float4 patchCoord : PATCHCOORD; // u, v, level, faceID\n"
"    noperspective float4 edgeDistance : EDGEDISTANCE;\n"
"#if defined(OSD_COMPUTE_NORMAL_DERIVATIVES)\n"
"    float3 Nu : TANGENT2;\n"
"    float3 Nv : TANGENT3;\n"
"#endif\n"
"};\n"
"\n"
"struct GregHullVertex {\n"
"    float3 position : POSITION0;\n"
"    float3 hullPosition : HULLPOSITION;\n"
"    int3 clipFlag : CLIPFLAG;\n"
"    int valence : BLENDINDICE0;\n"
"    float3 e0 : POSITION1;\n"
"    float3 e1 : POSITION2;\n"
"    uint zerothNeighbor : BLENDINDICE1;\n"
"    float3 org : POSITION3;\n"
"#if OSD_MAX_VALENCE > 0\n"
"    float3 r[OSD_MAX_VALENCE] : POSITION4;\n"
"#endif\n"
"};\n"
"\n"
"struct GregDomainVertex {\n"
"    float3 position : POSITION0;\n"
"    float3 Ep : POSITION1;\n"
"    float3 Em : POSITION2;\n"
"    float3 Fp : POSITION3;\n"
"    float3 Fm : POSITION4;\n"
"    float4 patchCoord: TEXTURE0;\n"
"    float4 ptexInfo: TEXTURE1;\n"
"};\n"
"\n"
"struct HS_CONSTANT_FUNC_OUT {\n"
"    float tessLevelInner[2] : SV_InsideTessFactor;\n"
"    float tessLevelOuter[4] : SV_TessFactor;\n"
"};\n"
"\n"
"cbuffer Transform : register( b0 ) {\n"
"    float4x4 ModelViewMatrix;\n"
"    float4x4 ProjectionMatrix;\n"
"    float4x4 ModelViewProjectionMatrix;\n"
"};\n"
"\n"
"cbuffer Tessellation : register( b1 ) {\n"
"    float TessLevel;\n"
"    int GregoryQuadOffsetBase;\n"
"    int PrimitiveIdBase;\n"
"};\n"
"\n"
"float GetTessLevel(int patchLevel)\n"
"{\n"
"#ifdef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"    return TessLevel;\n"
"#else\n"
"    return TessLevel / pow(2, patchLevel-1);\n"
"#endif\n"
"}\n"
"\n"
"float GetPostProjectionSphereExtent(float3 center, float diameter)\n"
"{\n"
"    float4 p = mul(ProjectionMatrix, float4(center, 1.0));\n"
"    return abs(diameter * ProjectionMatrix[1][1] / p.w);\n"
"}\n"
"\n"
"float TessAdaptive(float3 p0, float3 p1)\n"
"{\n"
"    // Adaptive factor can be any computation that depends only on arg values.\n"
"    // Project the diameter of the edge's bounding sphere instead of using the\n"
"    // length of the projected edge itself to avoid problems near silhouettes.\n"
"    float3 center = (p0 + p1) / 2.0;\n"
"    float diameter = distance(p0, p1);\n"
"    return max(1.0, TessLevel * GetPostProjectionSphereExtent(center, diameter));\n"
"}\n"
"\n"
"#ifndef OSD_DISPLACEMENT_CALLBACK\n"
"#define OSD_DISPLACEMENT_CALLBACK\n"
"#endif\n"
"\n"
"Buffer<int2> OsdPatchParamBuffer : register( t3 );\n"
"\n"
"#define GetPatchLevel(primitiveID)                                      "
"        (OsdPatchParamBuffer[primitiveID + PrimitiveIdBase].y & 0xf)\n"
"\n"
"#define OSD_COMPUTE_PTEX_COORD_HULL_SHADER                                    "
"    {                                                                         "
"        int2 ptexIndex = OsdPatchParamBuffer[primitiveID+PrimitiveIdBase].xy; "
"        int faceID = ptexIndex.x;                                             "
"        int lv = 1 << ((ptexIndex.y & 0xf) - ((ptexIndex.y >> 4) & 1));       "
"        int u = (ptexIndex.y >> 17) & 0x3ff;                                  "
"        int v = (ptexIndex.y >> 7) & 0x3ff;                                   "
"        int rotation = (ptexIndex.y >> 5) & 0x3;                              "
"        output.patchCoord.w = faceID+0.5;                                     "
"        output.ptexInfo = int4(u, v, lv, rotation);                           "
"    }\n"
"\n"
"#define OSD_COMPUTE_PTEX_COORD_DOMAIN_SHADER                            "
"    {                                                                   "
"        float2 uv = output.patchCoord.xy;                               "
"        int2 p = patch[0].ptexInfo.xy;                                  "
"        int lv = patch[0].ptexInfo.z;                                   "
"        int rot = patch[0].ptexInfo.w;                                  "
"        uv.xy = float(rot==0)*uv.xy                                     "
"            + float(rot==1)*float2(1.0-uv.y, uv.x)                      "
"            + float(rot==2)*float2(1.0-uv.x, 1.0-uv.y)                  "
"            + float(rot==3)*float2(uv.y, 1.0-uv.x);                     "
"        output.patchCoord.xy = (uv * float2(1.0,1.0)/lv) + float2(p.x, p.y)/lv; "
"    }\n"
"\n"
"#define OSD_COMPUTE_PTEX_COMPATIBLE_TANGENT(ROTATE)                 "
"    {                                                               "
"        int rot = (patch[0].ptexInfo.w + 4 - ROTATE)%4;             "
"        if (rot == 1) {                                             "
"            output.tangent = -BiTangent;                            "
"            output.bitangent = Tangent;                             "
"        } else if (rot == 2) {                                      "
"            output.tangent = -Tangent;                              "
"            output.bitangent = -BiTangent;                          "
"        } else if (rot == 3) {                                      "
"            output.tangent = BiTangent;                             "
"            output.bitangent = -Tangent;                            "
"        } else {                                                    "
"            output.tangent = Tangent;                               "
"            output.bitangent = BiTangent;                           "
"        }                                                           "
"    }\n"
"\n"
"#define OSD_COMPUTE_PTEX_COMPATIBLE_DERIVATIVES(ROTATE)             "
"    {                                                               "
"        int rot = (patch[0].ptexInfo.w + 4 - ROTATE)%4;             "
"        if (rot == 1) {                                             "
"            output.tangent = -BiTangent;                            "
"            output.bitangent = Tangent;                             "
"            output.Nu = -Nv;                                        "
"            output.Nv = Nv;                                         "
"        } else if (rot == 2) {                                      "
"            output.tangent = -Tangent;                              "
"            output.bitangent = -BiTangent;                          "
"            output.Nu = -Nu;                                        "
"            output.Nv = -Nv;                                        "
"        } else if (rot == 3) {                                      "
"            output.tangent = BiTangent;                             "
"            output.bitangent = -Tangent;                            "
"            output.Nu = Nv;                                         "
"            output.Nv = -Nu;                                        "
"        } else {                                                    "
"            output.tangent = Tangent;                               "
"            output.bitangent = BiTangent;                           "
"            output.Nu = Nu;                                         "
"            output.Nv = Nv;                                         "
"        }                                                           "
"    }\n"
"\n"
"\n"
"#ifdef OSD_ENABLE_PATCH_CULL\n"
"\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)                     "
"    float4 clipPos = mul(ModelViewProjectionMatrix, P);         "
"    int3 clip0 = int3(clipPos.x < clipPos.w,                    "
"                      clipPos.y < clipPos.w,                    "
"                      clipPos.z < clipPos.w);                   "
"    int3 clip1 = int3(clipPos.x > -clipPos.w,                   "
"                      clipPos.y > -clipPos.w,                   "
"                      clipPos.z > -clipPos.w);                  "
"    output.clipFlag = int3(clip0) + 2*int3(clip1);              "
"\n"
"#define OSD_PATCH_CULL(N)                          "
"    int3 clipFlag = int3(0,0,0);                   "
"    for(int i = 0; i < N; ++i) {                   "
"        clipFlag |= patch[i].clipFlag;             "
"    }                                              "
"    if (any(clipFlag != int3(3,3,3))) {            "
"        output.tessLevelInner[0] = 0;              "
"        output.tessLevelInner[1] = 0;              "
"        output.tessLevelOuter[0] = 0;              "
"        output.tessLevelOuter[1] = 0;              "
"        output.tessLevelOuter[2] = 0;              "
"        output.tessLevelOuter[3] = 0;              "
"        return output;                             "
"    }\n"
"\n"
"#define OSD_PATCH_CULL_TRIANGLE(N)                 "
"    int3 clipFlag = int3(0,0,0);                   "
"    for(int i = 0; i < N; ++i) {                   "
"        clipFlag |= patch[i].clipFlag;             "
"    }                                              "
"    if (any(clipFlag != int3(3,3,3))) {            "
"        output.tessLevelInner    = 0;              "
"        output.tessLevelOuter[0] = 0;              "
"        output.tessLevelOuter[1] = 0;              "
"        output.tessLevelOuter[2] = 0;              "
"        return output;                             "
"    }\n"
"\n"
"#else\n"
"#define OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(P)\n"
"#define OSD_PATCH_CULL(N)\n"
"#define OSD_PATCH_CULL_TRIANGLE(N)\n"
"#endif\n"
"\n"
"void Univar4x4(in float u, out float B[4], out float D[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 =     s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] =          s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"}\n"
"\n"
"void\n"
"Univar4x4(in float u, out float B[4], out float D[4], out float C[4])\n"
"{\n"
"    float t = u;\n"
"    float s = 1.0f - u;\n"
"\n"
"    float A0 = s * s;\n"
"    float A1 = 2 * s * t;\n"
"    float A2 = t * t;\n"
"\n"
"    B[0] = s * A0;\n"
"    B[1] = t * A0 + s * A1;\n"
"    B[2] = t * A1 + s * A2;\n"
"    B[3] = t * A2;\n"
"\n"
"    D[0] =    - A0;\n"
"    D[1] = A0 - A1;\n"
"    D[2] = A1 - A2;\n"
"    D[3] = A2;\n"
"\n"
"    A0 =   - s;\n"
"    A1 = s - t;\n"
"    A2 = t;\n"
"\n"
"    C[0] =    - A0;\n"
"    C[1] = A0 - A1;\n"
"    C[2] = A1 - A2;\n"
"    C[3] = A2;\n"
"}\n"
"\n"
