"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifndef M_PI\n"
"    #define M_PI 3.14159265358979323846  // fix for OSX 10.8 (M_PI is in the Khronos standard...)\n"
"#endif\n"
"\n"
"struct Vertex\n"
"{\n"
"    float v[NUM_VERTEX_ELEMENTS];\n"
"};\n"
"\n"
"struct Varying\n"
"{\n"
"    float v[NUM_VARYING_ELEMENTS];\n"
"};\n"
"\n"
"void clearVertex(struct Vertex *vertex) {\n"
"\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        vertex->v[i] = 0;\n"
"    }\n"
"}\n"
"void clearVarying(struct Varying *varying) {\n"
"\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        varying->v[i] = 0;\n"
"    }\n"
"}\n"
"\n"
"void addWithWeight(struct Vertex *dst, __global struct Vertex *src, float weight) {\n"
"\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        dst->v[i] += src->v[i] * weight;\n"
"    }\n"
"}\n"
"\n"
"void addVaryingWithWeight(struct Varying *dst, __global struct Varying *src, float weight) {\n"
"\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        dst->v[i] += src->v[i] * weight;\n"
"    }\n"
"}\n"
"\n"
"__kernel void computeBilinearEdge(__global struct Vertex *vertex,\n"
"                                  __global struct Varying *varying,\n"
"                                  __global int *E_IT,\n"
"                                  int vertexOffset, int tableOffset,\n"
"                                  int start, int end) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int vid = start + get_global_id(0) + vertexOffset;\n"
"    int eidx0 = E_IT[2*i+0];\n"
"    int eidx1 = E_IT[2*i+1];\n"
"\n"
"    struct Vertex dst;\n"
"    struct Varying dstVarying;\n"
"    clearVertex(&dst);\n"
"    clearVarying(&dstVarying);\n"
"\n"
"    addWithWeight(&dst, &vertex[eidx0], 0.5f);\n"
"    addWithWeight(&dst, &vertex[eidx1], 0.5f);\n"
"\n"
"    vertex[vid] = dst;\n"
"\n"
"    if (varying) {\n"
"        addVaryingWithWeight(&dstVarying, &varying[eidx0], 0.5f);\n"
"        addVaryingWithWeight(&dstVarying, &varying[eidx1], 0.5f);\n"
"        varying[vid] = dstVarying;\n"
"    }\n"
"}\n"
"\n"
"__kernel void computeBilinearVertex(__global struct Vertex *vertex,\n"
"                                    __global struct Varying *varying,\n"
"                                    __global int *V_ITa,\n"
"                                    int vertexOffset, int tableOffset,\n"
"                                    int start, int end) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int vid = start + get_global_id(0) + vertexOffset;\n"
"\n"
"    int p = V_ITa[i];\n"
"\n"
"    struct Vertex dst;\n"
"    clearVertex(&dst);\n"
"    addWithWeight(&dst, &vertex[p], 1.0f);\n"
"\n"
"    vertex[vid] = dst;\n"
"\n"
"    if (varying) {\n"
"        struct Varying dstVarying;\n"
"        clearVarying(&dstVarying);\n"
"        addVaryingWithWeight(&dstVarying, &varying[p], 1.0f);\n"
"        varying[vid] = dstVarying;\n"
"    }\n"
"}\n"
"\n"
"// ----------------------------------------------------------------------------------------\n"
"\n"
"__kernel void computeFace(__global struct Vertex *vertex,\n"
"                          __global struct Varying *varying,\n"
"                          __global int *F_IT,\n"
"                          __global int *F_ITa,\n"
"                          int vertexOffset, int tableOffset,\n"
"                          int start, int end) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int vid = start + get_global_id(0) + vertexOffset;\n"
"    int h = F_ITa[2*i];\n"
"    int n = F_ITa[2*i+1];\n"
"\n"
"    float weight = 1.0f/n;\n"
"\n"
"    struct Vertex dst;\n"
"    struct Varying dstVarying;\n"
"    clearVertex(&dst);\n"
"    clearVarying(&dstVarying);\n"
"    for (int j=0; j<n; ++j) {\n"
"        int index = F_IT[h+j];\n"
"        addWithWeight(&dst, &vertex[index], weight);\n"
"        if(varying) addVaryingWithWeight(&dstVarying, &varying[index], weight);\n"
"    }\n"
"    vertex[vid] = dst;\n"
"    if (varying) varying[vid] = dstVarying;\n"
"}\n"
"\n"
"__kernel void computeEdge(__global struct Vertex *vertex,\n"
"                          __global struct Varying *varying,\n"
"                          __global int *E_IT,\n"
"                          __global float *E_W,\n"
"                          int vertexOffset, int tableOffset,\n"
"                          int start, int end) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int vid = start + get_global_id(0) + vertexOffset;\n"
"    int eidx0 = E_IT[4*i+0];\n"
"    int eidx1 = E_IT[4*i+1];\n"
"    int eidx2 = E_IT[4*i+2];\n"
"    int eidx3 = E_IT[4*i+3];\n"
"\n"
"    float vertWeight = E_W[i*2+0];\n"
"\n"
"    // Fully sharp edge : vertWeight = 0.5f;\n"
"    struct Vertex dst;\n"
"    struct Varying dstVarying;\n"
"    clearVertex(&dst);\n"
"    clearVarying(&dstVarying);\n"
"\n"
"    addWithWeight(&dst, &vertex[eidx0], vertWeight);\n"
"    addWithWeight(&dst, &vertex[eidx1], vertWeight);\n"
"\n"
"    if (eidx2 > -1) {\n"
"        float faceWeight = E_W[i*2+1];\n"
"\n"
"        addWithWeight(&dst, &vertex[eidx2], faceWeight);\n"
"        addWithWeight(&dst, &vertex[eidx3], faceWeight);\n"
"    }\n"
"\n"
"    vertex[vid] = dst;\n"
"\n"
"    if (varying) {\n"
"        addVaryingWithWeight(&dstVarying, &varying[eidx0], 0.5f);\n"
"        addVaryingWithWeight(&dstVarying, &varying[eidx1], 0.5f);\n"
"        varying[vid] = dstVarying;\n"
"    }\n"
"}\n"
"\n"
"__kernel void computeVertexA(__global struct Vertex *vertex,\n"
"                             __global struct Varying *varying,\n"
"                             __global int *V_ITa,\n"
"                             __global float *V_W,\n"
"                             int vertexOffset, int tableOffset,\n"
"                             int start, int end, int pass) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int vid = start + get_global_id(0) + vertexOffset;\n"
"    int n     = V_ITa[5*i+1];\n"
"    int p     = V_ITa[5*i+2];\n"
"    int eidx0 = V_ITa[5*i+3];\n"
"    int eidx1 = V_ITa[5*i+4];\n"
"\n"
"    float weight = (pass==1) ? V_W[i] : 1.0f - V_W[i];\n"
"\n"
"    // In the case of fractional weight, the weight must be inverted since\n"
"    // the value is shared with the k_Smooth kernel (statistically the\n"
"    // k_Smooth kernel runs much more often than this one)\n"
"    if (weight>0.0f && weight<1.0f && n > 0)\n"
"        weight=1.0f-weight;\n"
"\n"
"    struct Vertex dst;\n"
"    if (! pass)\n"
"        clearVertex(&dst);\n"
"    else\n"
"        dst = vertex[vid];\n"
"\n"
"    if (eidx0==-1 || (pass==0 && (n==-1)) ) {\n"
"        addWithWeight(&dst, &vertex[p], weight);\n"
"    } else {\n"
"        addWithWeight(&dst, &vertex[p], weight * 0.75f);\n"
"        addWithWeight(&dst, &vertex[eidx0], weight * 0.125f);\n"
"        addWithWeight(&dst, &vertex[eidx1], weight * 0.125f);\n"
"    }\n"
"    vertex[vid] = dst;\n"
"\n"
"    if (! pass && varying) {\n"
"        struct Varying dstVarying;\n"
"        clearVarying(&dstVarying);\n"
"        addVaryingWithWeight(&dstVarying, &varying[p], 1.0f);\n"
"        varying[vid] = dstVarying;\n"
"    }\n"
"}\n"
"\n"
"__kernel void computeVertexB(__global struct Vertex *vertex,\n"
"                             __global struct Varying *varying,\n"
"                             __global int *V_ITa,\n"
"                             __global int *V_IT,\n"
"                             __global float *V_W,\n"
"                             int vertexOffset, int tableOffset,\n"
"                             int start, int end) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int vid = start + get_global_id(0) + vertexOffset;\n"
"    int h = V_ITa[5*i];\n"
"    int n = V_ITa[5*i+1];\n"
"    int p = V_ITa[5*i+2];\n"
"\n"
"    float weight = V_W[i];\n"
"    float wp = 1.0f/(float)(n*n);\n"
"    float wv = (n-2.0f) * n * wp;\n"
"\n"
"    struct Vertex dst;\n"
"    clearVertex(&dst);\n"
"\n"
"    addWithWeight(&dst, &vertex[p], weight * wv);\n"
"\n"
"    for (int j = 0; j < n; ++j) {\n"
"        addWithWeight(&dst, &vertex[V_IT[h+j*2]], weight * wp);\n"
"        addWithWeight(&dst, &vertex[V_IT[h+j*2+1]], weight * wp);\n"
"    }\n"
"    vertex[vid] = dst;\n"
"\n"
"    if (varying) {\n"
"        struct Varying dstVarying;\n"
"        clearVarying(&dstVarying);\n"
"        addVaryingWithWeight(&dstVarying, &varying[p], 1.0f);\n"
"        varying[vid] = dstVarying;\n"
"    }\n"
"}\n"
"\n"
"__kernel void computeLoopVertexB(__global struct Vertex *vertex,\n"
"                                 __global struct Varying *varying,\n"
"                                 __global int *V_ITa,\n"
"                                 __global int *V_IT,\n"
"                                 __global float *V_W,\n"
"                                 int vertexOffset, int tableOffset,\n"
"                                 int start, int end) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int vid = start + get_global_id(0) + vertexOffset;\n"
"    int h = V_ITa[5*i];\n"
"    int n = V_ITa[5*i+1];\n"
"    int p = V_ITa[5*i+2];\n"
"\n"
"    float weight = V_W[i];\n"
"    float wp = 1.0f/(float)(n);\n"
"    float beta = 0.25f * cos((float)(M_PI) * 2.0f * wp) + 0.375f;\n"
"    beta = beta * beta;\n"
"    beta = (0.625f - beta) * wp;\n"
"\n"
"    struct Vertex dst;\n"
"    clearVertex(&dst);\n"
"    addWithWeight(&dst, &vertex[p], weight * (1.0f - (beta * n)));\n"
"\n"
"    for (int j = 0; j < n; ++j) {\n"
"        addWithWeight(&dst, &vertex[V_IT[h+j]], weight * beta);\n"
"    }\n"
"    vertex[vid] = dst;\n"
"\n"
"    if (varying) {\n"
"        struct Varying dstVarying;\n"
"        clearVarying(&dstVarying);\n"
"        addVaryingWithWeight(&dstVarying, &varying[p], 1.0f);\n"
"        varying[vid] = dstVarying;\n"
"    }\n"
"}\n"
"\n"
"__kernel void editVertexAdd(__global struct Vertex *vertex,\n"
"                            __global int *editIndices,\n"
"                            __global float *editValues,\n"
"                            int primVarOffset,\n"
"                            int primVarWidth,\n"
"                            int vertexOffset, int tableOffset,\n"
"                            int start, int end) {\n"
"\n"
"    int i = start + get_global_id(0) + tableOffset;\n"
"    int v = editIndices[i];\n"
"    int eid = start + get_global_id(0);\n"
"    struct Vertex dst = vertex[v];\n"
"\n"
"    for (int j = 0; j < primVarWidth; ++j) {\n"
"        dst.v[j+primVarOffset] += editValues[eid*primVarWidth + j];\n"
"    }\n"
"    vertex[v] = dst;\n"
"}\n"
"\n"
