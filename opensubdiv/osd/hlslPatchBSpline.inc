"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#ifdef OSD_TRANSITION_TRIANGLE_SUBPATCH\n"
"    #define HS_DOMAIN \"tri\"\n"
"#else\n"
"    #define HS_DOMAIN \"quad\"\n"
"#endif\n"
"\n"
"#if defined OSD_FRACTIONAL_ODD_SPACING\n"
"    #define HS_PARTITION \"fractional_odd\"\n"
"#elif defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    #define HS_PARTITION \"fractional_even\"\n"
"#else\n"
"    #define HS_PARTITION \"integer\"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Vertex\n"
"//----------------------------------------------------------\n"
"\n"
"void vs_main_patches( in InputVertex input,\n"
"                      out HullVertex output )\n"
"{\n"
"    output.position = mul(ModelViewMatrix, input.position);\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(input.position);\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.HullBSpline\n"
"//----------------------------------------------------------\n"
"\n"
"// Regular\n"
"static float4x4 Q = {\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f, 0.f,\n"
"    0.f,     4.f/6.f, 2.f/6.f, 0.f,\n"
"    0.f,     2.f/6.f, 4.f/6.f, 0.f,\n"
"    0.f,     1.f/6.f, 4.f/6.f, 1.f/6.f\n"
"};\n"
"\n"
"// Boundary / Corner\n"
"static float4x3 B = {\n"
"    1.f,     0.f,     0.f,\n"
"    4.f/6.f, 2.f/6.f, 0.f,\n"
"    2.f/6.f, 4.f/6.f, 0.f,\n"
"    1.f/6.f, 4.f/6.f, 1.f/6.f\n"
"};\n"
"\n"
"#ifdef OSD_PATCH_TRANSITION\n"
"    HS_CONSTANT_TRANSITION_FUNC_OUT\n"
"#else\n"
"    HS_CONSTANT_FUNC_OUT\n"
"#endif\n"
"HSConstFunc(\n"
"    InputPatch<HullVertex, OSD_PATCH_INPUT_SIZE> patch,\n"
"    uint primitiveID : SV_PrimitiveID)\n"
"{\n"
"#ifdef OSD_PATCH_TRANSITION\n"
"    HS_CONSTANT_TRANSITION_FUNC_OUT output;\n"
"#else\n"
"    HS_CONSTANT_FUNC_OUT output;\n"
"#endif\n"
"    int patchLevel = GetPatchLevel(primitiveID);\n"
"\n"
"#ifdef OSD_TRANSITION_TRIANGLE_SUBPATCH\n"
"    OSD_PATCH_CULL_TRIANGLE(OSD_PATCH_INPUT_SIZE);\n"
"#else\n"
"    OSD_PATCH_CULL(OSD_PATCH_INPUT_SIZE);\n"
"#endif\n"
"\n"
"#ifdef OSD_PATCH_TRANSITION\n"
"    float3 cp[OSD_PATCH_INPUT_SIZE];\n"
"    for(int k = 0; k < OSD_PATCH_INPUT_SIZE; ++k) cp[k] = patch[k].position.xyz;\n"
"    SetTransitionTessLevels(output, cp, patchLevel);\n"
"#else\n"
"    #if defined OSD_PATCH_BOUNDARY\n"
"        const int p[4] = { 1, 2, 5, 6 };\n"
"    #elif defined OSD_PATCH_CORNER\n"
"        const int p[4] = { 1, 2, 4, 5 };\n"
"    #else\n"
"        const int p[4] = { 5, 6, 9, 10 };\n"
"    #endif\n"
"\n"
"    #ifdef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        output.tessLevelOuter[0] = TessAdaptive(patch[p[0]].position.xyz, patch[p[2]].position.xyz);\n"
"        output.tessLevelOuter[1] = TessAdaptive(patch[p[0]].position.xyz, patch[p[1]].position.xyz);\n"
"        output.tessLevelOuter[2] = TessAdaptive(patch[p[1]].position.xyz, patch[p[3]].position.xyz);\n"
"        output.tessLevelOuter[3] = TessAdaptive(patch[p[2]].position.xyz, patch[p[3]].position.xyz);\n"
"        output.tessLevelInner[0] = max(output.tessLevelOuter[1], output.tessLevelOuter[3]);\n"
"        output.tessLevelInner[1] = max(output.tessLevelOuter[0], output.tessLevelOuter[2]);\n"
"    #else\n"
"        output.tessLevelInner[0] = GetTessLevel(patchLevel);\n"
"        output.tessLevelInner[1] = GetTessLevel(patchLevel);\n"
"        output.tessLevelOuter[0] = GetTessLevel(patchLevel);\n"
"        output.tessLevelOuter[1] = GetTessLevel(patchLevel);\n"
"        output.tessLevelOuter[2] = GetTessLevel(patchLevel);\n"
"        output.tessLevelOuter[3] = GetTessLevel(patchLevel);\n"
"    #endif\n"
"#endif\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"[domain(HS_DOMAIN)]\n"
"[partitioning(HS_PARTITION)]\n"
"[outputtopology(\"triangle_cw\")]\n"
"[outputcontrolpoints(16)]\n"
"[patchconstantfunc(\"HSConstFunc\")]\n"
"HullVertex hs_main_patches(\n"
"    in InputPatch<HullVertex, OSD_PATCH_INPUT_SIZE> patch,\n"
"    uint primitiveID : SV_PrimitiveID,\n"
"    in uint ID : SV_OutputControlPointID )\n"
"{\n"
"    int i = ID%4;\n"
"    int j = ID/4;\n"
"\n"
"#if defined OSD_PATCH_BOUNDARY\n"
"    float3 H[3];\n"
"    for (int l=0; l<3; ++l) {\n"
"        H[l] = float3(0,0,0);\n"
"        for (int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * patch[l*4 + k].position.xyz;\n"
"        }\n"
"    }\n"
"\n"
"    float3 pos = float3(0,0,0);\n"
"    for (int k=0; k<3; ++k) {\n"
"        pos += B[j][k]*H[k];\n"
"    }\n"
"\n"
"#elif defined OSD_PATCH_CORNER\n"
"    float3 H[3];\n"
"    for (int l=0; l<3; ++l) {\n"
"        H[l] = float3(0,0,0);\n"
"        for (int k=0; k<3; ++k) {\n"
"            H[l] += B[3-i][2-k] * patch[l*3 + k].position.xyz;\n"
"        }\n"
"    }\n"
"\n"
"    float3 pos = float3(0,0,0);\n"
"    for (int k=0; k<3; ++k) {\n"
"        pos += B[j][k]*H[k];\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_BOUNDARY, not OSD_PATCH_CORNER\n"
"    float3 H[4];\n"
"    for (int l=0; l<4; ++l) {\n"
"        H[l] = float3(0,0,0);\n"
"        for(int k=0; k<4; ++k) {\n"
"            H[l] += Q[i][k] * patch[l*4 + k].position.xyz;\n"
"        }\n"
"    }\n"
"\n"
"    float3 pos = float3(0,0,0);\n"
"    for (int k=0; k<4; ++k){\n"
"        pos += Q[j][k]*H[k];\n"
"    }\n"
"\n"
"#endif\n"
"\n"
"    HullVertex output;\n"
"    output.position = float4(pos, 1.0);\n"
"\n"
"    int patchLevel = GetPatchLevel(primitiveID);\n"
"\n"
"    // +0.5 to avoid interpolation error of integer value\n"
"    output.patchCoord = float4(0, 0,\n"
"                               patchLevel+0.5,\n"
"                               primitiveID+PrimitiveIdBase+0.5);\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_HULL_SHADER;\n"
"\n"
"    return output;\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.DomainBSpline\n"
"//----------------------------------------------------------\n"
"\n"
"[domain(HS_DOMAIN)]\n"
"void ds_main_patches(\n"
"#ifdef OSD_PATCH_TRANSITION\n"
"    in HS_CONSTANT_TRANSITION_FUNC_OUT input,\n"
"#else\n"
"    in HS_CONSTANT_FUNC_OUT input,\n"
"#endif\n"
"    in OutputPatch<HullVertex, 16> patch,\n"
"#ifdef OSD_TRANSITION_TRIANGLE_SUBPATCH\n"
"    in float3 domainCoord : SV_DomainLocation,\n"
"#else\n"
"    in float2 domainCoord : SV_DomainLocation,\n"
"#endif\n"
"    out OutputVertex output )\n"
"{\n"
"#ifdef OSD_PATCH_TRANSITION\n"
"    float2 UV = GetTransitionSubpatchUV(domainCoord);\n"
"#else\n"
"    float2 UV = domainCoord;\n"
"#endif\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    float B[4], D[4], C[4];\n"
"    float3 BUCP[4], DUCP[4], CUCP[4];\n"
"    Univar4x4(UV.x, B, D, C);\n"
"#else\n"
"    float B[4], D[4];\n"
"    float3 BUCP[4], DUCP[4];\n"
"    Univar4x4(UV.x, B, D);\n"
"#endif\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        BUCP[i] = float3(0,0,0);\n"
"        DUCP[i] = float3(0,0,0);\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"        CUCP[i] = float3(0,0,0);\n"
"#endif\n"
"\n"
"        for (int j=0; j<4; ++j) {\n"
"#if OSD_TRANSITION_ROTATE == 1\n"
"            float3 A = patch[4*(3-j) + i].position.xyz;\n"
"#elif OSD_TRANSITION_ROTATE == 2\n"
"            float3 A = patch[4*(3-i) + (3-j)].position.xyz;\n"
"#elif OSD_TRANSITION_ROTATE == 3\n"
"            float3 A = patch[4*j + (3-i)].position.xyz;\n"
"#else // OSD_TRANSITION_ROTATE == 0, or non-transition patch\n"
"            float3 A = patch[4*i + j].position.xyz;\n"
"#endif\n"
"            BUCP[i] += A * B[j];\n"
"            DUCP[i] += A * D[j];\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"            CUCP[i] += A * C[j];\n"
"#endif\n"
"        }\n"
"    }\n"
"\n"
"    float3 WorldPos  = float3(0,0,0);\n"
"    float3 Tangent   = float3(0,0,0);\n"
"    float3 BiTangent = float3(0,0,0);\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    // used for weingarten term\n"
"    Univar4x4(UV.y, B, D, C);\n"
"\n"
"    float3 dUU = float3(0,0,0);\n"
"    float3 dVV = float3(0,0,0);\n"
"    float3 dUV = float3(0,0,0);\n"
"\n"
"    for (int k=0; k<4; ++k) {\n"
"        WorldPos  += B[k] * BUCP[k];\n"
"        Tangent   += B[k] * DUCP[k];\n"
"        BiTangent += D[k] * BUCP[k];\n"
"\n"
"        dUU += B[k] * CUCP[k];\n"
"        dVV += C[k] * BUCP[k];\n"
"        dUV += D[k] * DUCP[k];\n"
"    }\n"
"\n"
"    int level = int(patch[0].ptexInfo.z);\n"
"    Tangent *= 3 * level;\n"
"    BiTangent *= 3 * level;\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    float3 n = cross(Tangent, BiTangent);\n"
"    float3 normal = normalize(n);\n"
"\n"
"    float E = dot(Tangent, Tangent);\n"
"    float F = dot(Tangent, BiTangent);\n"
"    float G = dot(BiTangent, BiTangent);\n"
"    float e = dot(normal, dUU);\n"
"    float f = dot(normal, dUV);\n"
"    float g = dot(normal, dVV);\n"
"\n"
"    float3 Nu = (f*F-e*G)/(E*G-F*F) * Tangent + (e*F-f*E)/(E*G-F*F) * BiTangent;\n"
"    float3 Nv = (g*F-f*G)/(E*G-F*F) * Tangent + (f*F-g*E)/(E*G-F*F) * BiTangent;\n"
"\n"
"    Nu = Nu/length(n) - n * (dot(Nu,n)/pow(dot(n,n), 1.5));\n"
"    Nv = Nv/length(n) - n * (dot(Nv,n)/pow(dot(n,n), 1.5));\n"
"\n"
"    OSD_COMPUTE_PTEX_COMPATIBLE_DERIVATIVES(OSD_TRANSITION_ROTATE);\n"
"#else\n"
"    Univar4x4(UV.y, B, D);\n"
"\n"
"    for (int k=0; k<4; ++k) {\n"
"        WorldPos  += B[k] * BUCP[k];\n"
"        Tangent   += B[k] * DUCP[k];\n"
"        BiTangent += D[k] * BUCP[k];\n"
"    }\n"
"    int level = int(patch[0].ptexInfo.z);\n"
"    Tangent *= 3 * level;\n"
"    BiTangent *= 3 * level;\n"
"\n"
"    float3 normal = normalize(cross(Tangent, BiTangent));\n"
"\n"
"    OSD_COMPUTE_PTEX_COMPATIBLE_TANGENT(OSD_TRANSITION_ROTATE);\n"
"#endif\n"
"\n"
"    output.position = float4(WorldPos, 1.0f);\n"
"    output.normal = normal;\n"
"\n"
"    output.patchCoord = patch[0].patchCoord;\n"
"\n"
"#if OSD_TRANSITION_ROTATE == 1\n"
"    output.patchCoord.xy = float2(UV.y, 1.0-UV.x);\n"
"#elif OSD_TRANSITION_ROTATE == 2\n"
"    output.patchCoord.xy = float2(1.0-UV.x, 1.0-UV.y);\n"
"#elif OSD_TRANSITION_ROTATE == 3\n"
"    output.patchCoord.xy = float2(1.0-UV.y, UV.x);\n"
"#else // OSD_TRANNSITION_ROTATE == 0, or non-transition patch\n"
"    output.patchCoord.xy = float2(UV.x, UV.y);\n"
"#endif\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_DOMAIN_SHADER;\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    output.positionOut = mul(ProjectionMatrix,\n"
"                             float4(output.position.xyz, 1.0f));\n"
"}\n"
"\n"
