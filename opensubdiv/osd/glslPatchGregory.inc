"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.Coefficients\n"
"//----------------------------------------------------------\n"
"\n"
"#if OSD_MAX_VALENCE<=10\n"
"uniform float ef[7] = float[](\n"
"    0.813008, 0.500000, 0.363636, 0.287505,\n"
"    0.238692, 0.204549, 0.179211\n"
");\n"
"#else\n"
"uniform float ef[27] = float[](\n"
"    0.812816, 0.500000, 0.363644, 0.287514,\n"
"    0.238688, 0.204544, 0.179229, 0.159657,\n"
"    0.144042, 0.131276, 0.120632, 0.111614,\n"
"    0.103872, 0.09715, 0.0912559, 0.0860444,\n"
"    0.0814022, 0.0772401, 0.0734867, 0.0700842,\n"
"    0.0669851, 0.0641504, 0.0615475, 0.0591488,\n"
"    0.0569311, 0.0548745, 0.0529621\n"
");\n"
"#endif\n"
"\n"
"float csf(uint n, uint j)\n"
"{\n"
"    if (j%2 == 0) {\n"
"        return cos((2.0f * M_PI * float(float(j-0)/2.0f))/(float(n)+3.0f));\n"
"    } else {\n"
"        return sin((2.0f * M_PI * float(float(j-1)/2.0f))/(float(n)+3.0f));\n"
"    }\n"
"}\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessVertexGregory\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_VERTEX_GREGORY_SHADER\n"
"\n"
"uniform samplerBuffer OsdVertexBuffer;\n"
"uniform isamplerBuffer OsdValenceBuffer;\n"
"\n"
"layout (location=0) in vec4 position;\n"
"OSD_USER_VARYING_ATTRIBUTE_DECLARE\n"
"\n"
"out block {\n"
"    GregControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    int vID = gl_VertexID;\n"
"\n"
"    outpt.v.hullPosition = (ModelViewMatrix * position).xyz;\n"
"    OSD_PATCH_CULL_COMPUTE_CLIPFLAGS(position);\n"
"    OSD_USER_VARYING_PER_VERTEX();\n"
"\n"
"    int ivalence = texelFetch(OsdValenceBuffer,int(vID * (2 * OSD_MAX_VALENCE + 1))).x;\n"
"    outpt.v.valence = ivalence;\n"
"    uint valence = uint(abs(ivalence));\n"
"\n"
"    vec3 f[OSD_MAX_VALENCE]; \n"
"    vec3 pos = position.xyz;\n"
"    vec3 opos = vec3(0,0,0);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    outpt.v.org = position.xyz;\n"
"    int boundaryEdgeNeighbors[2];\n"
"    uint currNeighbor = 0;\n"
"    uint ibefore = 0;\n"
"    uint zerothNeighbor = 0;\n"
"#endif\n"
"\n"
"    for (uint i=0; i<valence; ++i) {\n"
"        uint im=(i+valence-1)%valence; \n"
"        uint ip=(i+1)%valence; \n"
"\n"
"        uint idx_neighbor = uint(texelFetch(OsdValenceBuffer, int(vID * (2*OSD_MAX_VALENCE+1) + 2*i + 0 + 1)).x);\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"        bool isBoundaryNeighbor = false;\n"
"        int valenceNeighbor = texelFetch(OsdValenceBuffer,int(idx_neighbor * (2*OSD_MAX_VALENCE+1))).x;\n"
"\n"
"        if (valenceNeighbor < 0) {\n"
"            isBoundaryNeighbor = true;\n"
"            boundaryEdgeNeighbors[currNeighbor++] = int(idx_neighbor);\n"
"            if (currNeighbor == 1)    {\n"
"                ibefore = i;\n"
"                zerothNeighbor = i;\n"
"            } else {\n"
"                if (i-ibefore == 1) {\n"
"                    int tmp = boundaryEdgeNeighbors[0];\n"
"                    boundaryEdgeNeighbors[0] = boundaryEdgeNeighbors[1];\n"
"                    boundaryEdgeNeighbors[1] = tmp;\n"
"                    zerothNeighbor = i;\n"
"                } \n"
"            }\n"
"        }\n"
"#endif\n"
"\n"
"        vec3 neighbor =\n"
"            vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor+1)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor+2)).x);\n"
"\n"
"        uint idx_diagonal = uint(texelFetch(OsdValenceBuffer, int(vID * (2*OSD_MAX_VALENCE+1) + 2*i + 1 + 1)).x);\n"
"\n"
"        vec3 diagonal =\n"
"            vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal+1)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal+2)).x);\n"
"\n"
"        uint idx_neighbor_p = uint(texelFetch(OsdValenceBuffer, int(vID * (2*OSD_MAX_VALENCE+1) + 2*ip + 0 + 1)).x);\n"
"\n"
"        vec3 neighbor_p =\n"
"            vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor_p)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor_p+1)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor_p+2)).x);\n"
"\n"
"        uint idx_neighbor_m = uint(texelFetch(OsdValenceBuffer, int(vID * (2*OSD_MAX_VALENCE+1) + 2*im + 0 + 1)).x);\n"
"\n"
"        vec3 neighbor_m =\n"
"            vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor_m)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor_m+1)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor_m+2)).x);\n"
"\n"
"        uint idx_diagonal_m = uint(texelFetch(OsdValenceBuffer, int(vID * (2*OSD_MAX_VALENCE+1) + 2*im + 1 + 1)).x);\n"
"\n"
"        vec3 diagonal_m =\n"
"            vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal_m)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal_m+1)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal_m+2)).x);\n"
"\n"
"        f[i] = (pos * float(valence) + (neighbor_p + neighbor)*2.0f + diagonal) / (float(valence)+5.0f);\n"
"\n"
"        opos += f[i];\n"
"        outpt.v.r[i] = (neighbor_p-neighbor_m)/3.0f + (diagonal - diagonal_m)/6.0f;\n"
"    }\n"
"\n"
"    opos /= valence;\n"
"    outpt.v.position = vec4(opos, 1.0f).xyz;\n"
"\n"
"    vec3 e;\n"
"    outpt.v.e0 = vec3(0,0,0);\n"
"    outpt.v.e1 = vec3(0,0,0);\n"
"\n"
"    for(uint i=0; i<valence; ++i) {\n"
"        uint im = (i + valence -1) % valence;\n"
"        e = 0.5f * (f[i] + f[im]);\n"
"        outpt.v.e0 += csf(valence-3, 2*i) *e;\n"
"        outpt.v.e1 += csf(valence-3, 2*i + 1)*e;\n"
"    }\n"
"    outpt.v.e0 *= ef[valence - 3];\n"
"    outpt.v.e1 *= ef[valence - 3];\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    outpt.v.zerothNeighbor = zerothNeighbor;\n"
"    if (currNeighbor == 1) {\n"
"        boundaryEdgeNeighbors[1] = boundaryEdgeNeighbors[0];\n"
"    }\n"
"\n"
"    if (ivalence < 0) {\n"
"        if (valence > 2) {\n"
"            outpt.v.position = (\n"
"                vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0])).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+1)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+2)).x) +\n"
"                vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1])).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+1)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+2)).x) +\n"
"                4.0f * pos)/6.0f;        \n"
"        } else {\n"
"            outpt.v.position = pos;                    \n"
"        }\n"
"\n"
"        outpt.v.e0 = ( \n"
"            vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0])).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+1)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+2)).x) -\n"
"            vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1])).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+1)).x,\n"
"                 texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+2)).x) \n"
"            )/6.0;\n"
"\n"
"        float k = float(float(valence) - 1.0f);    //k is the number of faces\n"
"        float c = cos(M_PI/k);\n"
"        float s = sin(M_PI/k);\n"
"        float gamma = -(4.0f*s)/(3.0f*k+c);\n"
"        float alpha_0k = -((1.0f+2.0f*c)*sqrt(1.0f+c))/((3.0f*k+c)*sqrt(1.0f-c));\n"
"        float beta_0 = s/(3.0f*k + c); \n"
"\n"
"\n"
"        int idx_diagonal = texelFetch(OsdValenceBuffer,int((vID) * (2*OSD_MAX_VALENCE+1) + 2*zerothNeighbor + 1 + 1)).x;\n"
"        idx_diagonal = abs(idx_diagonal);\n"
"        vec3 diagonal =\n"
"                vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal+1)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal+2)).x);\n"
"\n"
"        outpt.v.e1 = gamma * pos + \n"
"            alpha_0k * vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0])).x,\n"
"                            texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+1)).x,\n"
"                            texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[0]+2)).x) +\n"
"            alpha_0k * vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1])).x,\n"
"                            texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+1)).x,\n"
"                            texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*boundaryEdgeNeighbors[1]+2)).x) +\n"
"            beta_0 * diagonal;\n"
"\n"
"        for (uint x=1; x<valence - 1; ++x) {\n"
"            uint curri = ((x + zerothNeighbor)%valence);\n"
"            float alpha = (4.0f*sin((M_PI * float(x))/k))/(3.0f*k+c);\n"
"            float beta = (sin((M_PI * float(x))/k) + sin((M_PI * float(x+1))/k))/(3.0f*k+c);\n"
"\n"
"            int idx_neighbor = texelFetch(OsdValenceBuffer, int((vID) * (2*OSD_MAX_VALENCE+1) + 2*curri + 0 + 1)).x;\n"
"            idx_neighbor = abs(idx_neighbor);\n"
"\n"
"            vec3 neighbor =\n"
"                vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor+1)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_neighbor+2)).x);\n"
"\n"
"            idx_diagonal = texelFetch(OsdValenceBuffer, int((vID) * (2*OSD_MAX_VALENCE+1) + 2*curri + 1 + 1)).x;\n"
"\n"
"            diagonal =\n"
"                vec3(texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal+1)).x,\n"
"                     texelFetch(OsdVertexBuffer, int(OSD_NUM_ELEMENTS*idx_diagonal+2)).x);\n"
"\n"
"            outpt.v.e1 += alpha * neighbor + beta * diagonal;                         \n"
"        }\n"
"\n"
"        outpt.v.e1 /= 3.0f;\n"
"    } \n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessControlGregory\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_CONTROL_GREGORY_SHADER\n"
"\n"
"layout(vertices = 4) out;\n"
"\n"
"uniform isamplerBuffer OsdQuadOffsetBuffer;\n"
"\n"
"in block {\n"
"    GregControlVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    GregEvalVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt[];\n"
"\n"
"#define ID gl_InvocationID\n"
"\n"
"void main()\n"
"{\n"
"    uint i = gl_InvocationID;\n"
"    uint ip = (i+1)%4;\n"
"    uint im = (i+3)%4;\n"
"    uint valence = abs(inpt[i].v.valence);\n"
"    uint n = valence;\n"
"    int base = OsdGregoryQuadOffsetBase;\n"
"\n"
"    outpt[ID].v.position = inpt[ID].v.position;\n"
"\n"
"    uint start = uint(texelFetch(OsdQuadOffsetBuffer, int(4*gl_PrimitiveID+base + i)).x) & 0x00ffu;\n"
"    uint prev = uint(texelFetch(OsdQuadOffsetBuffer, int(4*gl_PrimitiveID+base + i)).x) & 0xff00u;\n"
"    prev = uint(prev/256);\n"
"\n"
"    uint start_m = uint(texelFetch(OsdQuadOffsetBuffer, int(4*gl_PrimitiveID+base + im)).x) & 0x00ffu;\n"
"    uint prev_p = uint(texelFetch(OsdQuadOffsetBuffer, int(4*gl_PrimitiveID+base + ip)).x) & 0xff00u;\n"
"    prev_p = uint(prev_p/256);\n"
"\n"
"    uint np = abs(inpt[ip].v.valence);\n"
"    uint nm = abs(inpt[im].v.valence);\n"
"\n"
"    // Control Vertices based on : \n"
"    // \"Approximating Subdivision Surfaces with Gregory Patches for Hardware Tessellation\" \n"
"    // Loop, Schaefer, Ni, Castafio (ACM ToG Siggraph Asia 2009)\n"
"    //\n"
"    //  P3         e3-      e2+         E2\n"
"    //     O--------O--------O--------O\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     |        | f3-    | f2+    |\n"
"    //     |        O        O        |\n"
"    // e3+ O------O            O------O e2-\n"
"    //     |     f3+          f2-     |\n"
"    //     |                          |\n"
"    //     |                          |\n"
"    //     |      f0-         f1+     |\n"
"    // e0- O------O            O------O e1+\n"
"    //     |        O        O        |\n"
"    //     |        | f0+    | f1-    |\n"
"    //     |        |        |        |\n"
"    //     |        |        |        |\n"
"    //     O--------O--------O--------O\n"
"    //  P0         e0+      e1-         E1\n"
"    //\n"
"\n"
"#ifdef OSD_PATCH_GREGORY_BOUNDARY\n"
"    vec3 Ep = vec3(0.0f,0.0f,0.0f);\n"
"    vec3 Em = vec3(0.0f,0.0f,0.0f);\n"
"    vec3 Fp = vec3(0.0f,0.0f,0.0f);\n"
"    vec3 Fm = vec3(0.0f,0.0f,0.0f);\n"
"\n"
"    vec3 Em_ip;\n"
"    if (inpt[ip].v.valence < -2) {\n"
"        uint j = (np + prev_p - inpt[ip].v.zerothNeighbor) % np;\n"
"        Em_ip = inpt[ip].v.position + cos((M_PI*j)/float(np-1))*inpt[ip].v.e0 + sin((M_PI*j)/float(np-1))*inpt[ip].v.e1;\n"
"    } else {\n"
"        Em_ip = inpt[ip].v.position + inpt[ip].v.e0*csf(np-3, 2*prev_p ) + inpt[ip].v.e1*csf(np-3, 2*prev_p + 1);\n"
"    }\n"
"\n"
"    vec3 Ep_im;\n"
"    if (inpt[im].v.valence < -2) {\n"
"        uint j = (nm + start_m - inpt[im].v.zerothNeighbor) % nm;\n"
"        Ep_im = inpt[im].v.position + cos((M_PI*j)/float(nm-1))*inpt[im].v.e0 + sin((M_PI*j)/float(nm-1))*inpt[im].v.e1;\n"
"    } else {\n"
"        Ep_im = inpt[im].v.position + inpt[im].v.e0*csf(nm-3, 2*start_m) + inpt[im].v.e1*csf(nm-3, 2*start_m + 1);\n"
"    }\n"
"\n"
"    if (inpt[i].v.valence < 0) {\n"
"        n = (n-1)*2;\n"
"    }\n"
"    if (inpt[im].v.valence < 0) {\n"
"        nm = (nm-1)*2;\n"
"    }  \n"
"    if (inpt[ip].v.valence < 0) {\n"
"        np = (np-1)*2;\n"
"    }\n"
"\n"
"    if (inpt[i].v.valence > 2) {\n"
"        Ep = inpt[i].v.position + inpt[i].v.e0*csf(n-3, 2*start) + inpt[i].v.e1*csf(n-3, 2*start + 1);\n"
"        Em = inpt[i].v.position + inpt[i].v.e0*csf(n-3, 2*prev ) + inpt[i].v.e1*csf(n-3, 2*prev + 1); \n"
"\n"
"        float s1=3-2*csf(n-3,2)-csf(np-3,2);\n"
"        float s2=2*csf(n-3,2);\n"
"\n"
"        Fp = (csf(np-3,2)*inpt[i].v.position + s1*Ep + s2*Em_ip + inpt[i].v.r[start])/3.0f; \n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        Fm = (csf(nm-3,2)*inpt[i].v.position + s1*Em + s2*Ep_im - inpt[i].v.r[prev])/3.0f;\n"
"\n"
"    } else if (inpt[i].v.valence < -2) {\n"
"        uint j = (valence + start - inpt[i].v.zerothNeighbor) % valence;\n"
"\n"
"        Ep = inpt[i].v.position + cos((M_PI*j)/float(valence-1))*inpt[i].v.e0 + sin((M_PI*j)/float(valence-1))*inpt[i].v.e1;\n"
"        j = (valence + prev - inpt[i].v.zerothNeighbor) % valence;\n"
"        Em = inpt[i].v.position + cos((M_PI*j)/float(valence-1))*inpt[i].v.e0 + sin((M_PI*j)/float(valence-1))*inpt[i].v.e1;\n"
"\n"
"        vec3 Rp = ((-2.0f * inpt[i].v.org - 1.0f * inpt[im].v.org) + (2.0f * inpt[ip].v.org + 1.0f * inpt[(i+2)%4].v.org))/3.0f;\n"
"        vec3 Rm = ((-2.0f * inpt[i].v.org - 1.0f * inpt[ip].v.org) + (2.0f * inpt[im].v.org + 1.0f * inpt[(i+2)%4].v.org))/3.0f;\n"
"\n"
"        float s1 = 3-2*csf(n-3,2)-csf(np-3,2);\n"
"        float s2 = 2*csf(n-3,2);\n"
"\n"
"        Fp = (csf(np-3,2)*inpt[i].v.position + s1*Ep + s2*Em_ip + inpt[i].v.r[start])/3.0f; \n"
"        s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"        Fm = (csf(nm-3,2)*inpt[i].v.position + s1*Em + s2*Ep_im - inpt[i].v.r[prev])/3.0f;\n"
"\n"
"        if (inpt[im].v.valence < 0) {\n"
"            s1 = 3-2*csf(n-3,2)-csf(np-3,2);\n"
"            Fp = Fm = (csf(np-3,2)*inpt[i].v.position + s1*Ep + s2*Em_ip + inpt[i].v.r[start])/3.0f;\n"
"        } else if (inpt[ip].v.valence < 0) {\n"
"            s1 = 3.0f-2.0f*cos(2.0f*M_PI/n)-cos(2.0f*M_PI/nm);\n"
"            Fm = Fp = (csf(nm-3,2)*inpt[i].v.position + s1*Em + s2*Ep_im - inpt[i].v.r[prev])/3.0f;\n"
"        }\n"
"\n"
"    } else if (inpt[i].v.valence == -2) {\n"
"        Ep = (2.0f * inpt[i].v.org + inpt[ip].v.org)/3.0f;\n"
"        Em = (2.0f * inpt[i].v.org + inpt[im].v.org)/3.0f;\n"
"        Fp = Fm = (4.0f * inpt[i].v.org + inpt[(i+2)%n].v.org + 2.0f * inpt[ip].v.org + 2.0f * inpt[im].v.org)/9.0f;\n"
"    }\n"
"\n"
"#else // not OSD_PATCH_GREGORY_BOUNDARY\n"
"\n"
"    vec3 Ep = inpt[i].v.position + inpt[i].v.e0 * csf(n-3, 2*start) + inpt[i].v.e1*csf(n-3, 2*start + 1);\n"
"    vec3 Em = inpt[i].v.position + inpt[i].v.e0 * csf(n-3, 2*prev ) + inpt[i].v.e1*csf(n-3, 2*prev + 1);\n"
"\n"
"    vec3 Em_ip = inpt[ip].v.position + inpt[ip].v.e0 * csf(np-3, 2*prev_p ) + inpt[ip].v.e1*csf(np-3, 2*prev_p + 1);\n"
"    vec3 Ep_im = inpt[im].v.position + inpt[im].v.e0 * csf(nm-3, 2*start_m) + inpt[im].v.e1*csf(nm-3, 2*start_m + 1);\n"
"\n"
"    float s1 = 3-2*csf(n-3,2)-csf(np-3,2);\n"
"    float s2 = 2*csf(n-3,2);\n"
"\n"
"    vec3 Fp = (csf(np-3,2)*inpt[i].v.position + s1*Ep + s2*Em_ip + inpt[i].v.r[start])/3.0f;\n"
"    s1 = 3.0f-2.0f*cos(2.0f*M_PI/float(n))-cos(2.0f*M_PI/float(nm));\n"
"    vec3 Fm = (csf(nm-3,2)*inpt[i].v.position + s1*Em + s2*Ep_im - inpt[i].v.r[prev])/3.0f;\n"
"\n"
"#endif\n"
"\n"
"    outpt[ID].v.Ep = Ep;\n"
"    outpt[ID].v.Em = Em;\n"
"    outpt[ID].v.Fp = Fp;\n"
"    outpt[ID].v.Fm = Fm;\n"
"\n"
"    OSD_USER_VARYING_PER_CONTROL_POINT(ID, ID);\n"
"\n"
"    int patchLevel = GetPatchLevel();\n"
"    outpt[ID].v.patchCoord = vec4(0, 0,\n"
"                                  patchLevel+0.5f,\n"
"                                  gl_PrimitiveID+OsdPrimitiveIdBase+0.5f);\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_TESSCONTROL_SHADER;\n"
"\n"
"    if (ID == 0) {\n"
"        OSD_PATCH_CULL(4);\n"
"\n"
"#ifdef OSD_ENABLE_SCREENSPACE_TESSELLATION\n"
"        gl_TessLevelOuter[0] =\n"
"            TessAdaptive(inpt[0].v.hullPosition.xyz, inpt[1].v.hullPosition.xyz);\n"
"        gl_TessLevelOuter[1] =\n"
"            TessAdaptive(inpt[0].v.hullPosition.xyz, inpt[3].v.hullPosition.xyz);\n"
"        gl_TessLevelOuter[2] =\n"
"            TessAdaptive(inpt[2].v.hullPosition.xyz, inpt[3].v.hullPosition.xyz);\n"
"        gl_TessLevelOuter[3] =\n"
"            TessAdaptive(inpt[1].v.hullPosition.xyz, inpt[2].v.hullPosition.xyz);\n"
"        gl_TessLevelInner[0] =\n"
"            max(gl_TessLevelOuter[1], gl_TessLevelOuter[3]);\n"
"        gl_TessLevelInner[1] =\n"
"            max(gl_TessLevelOuter[0], gl_TessLevelOuter[2]);\n"
"#else\n"
"        gl_TessLevelInner[0] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelInner[1] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[0] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[1] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[2] = GetTessLevel(patchLevel);\n"
"        gl_TessLevelOuter[3] = GetTessLevel(patchLevel);\n"
"#endif\n"
"    }\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//----------------------------------------------------------\n"
"// Patches.TessEvalGregory\n"
"//----------------------------------------------------------\n"
"#ifdef OSD_PATCH_TESS_EVAL_GREGORY_SHADER\n"
"\n"
"layout(quads) in;\n"
"layout(cw) in;\n"
"\n"
"#if defined OSD_FRACTIONAL_ODD_SPACING\n"
"    layout(fractional_odd_spacing) in;\n"
"#elif defined OSD_FRACTIONAL_EVEN_SPACING\n"
"    layout(fractional_even_spacing) in;\n"
"#endif\n"
"\n"
"in block {\n"
"    GregEvalVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} inpt[];\n"
"\n"
"out block {\n"
"    OutputVertex v;\n"
"    OSD_USER_VARYING_DECLARE\n"
"} outpt;\n"
"\n"
"void main()\n"
"{\n"
"    float u = gl_TessCoord.x,\n"
"          v = gl_TessCoord.y;\n"
"\n"
"    vec3 p[20];\n"
"\n"
"    p[0] = inpt[0].v.position;\n"
"    p[1] = inpt[0].v.Ep;\n"
"    p[2] = inpt[0].v.Em;\n"
"    p[3] = inpt[0].v.Fp;\n"
"    p[4] = inpt[0].v.Fm;\n"
"\n"
"    p[5] = inpt[1].v.position;\n"
"    p[6] = inpt[1].v.Ep;\n"
"    p[7] = inpt[1].v.Em;\n"
"    p[8] = inpt[1].v.Fp;\n"
"    p[9] = inpt[1].v.Fm;\n"
"\n"
"    p[10] = inpt[2].v.position;\n"
"    p[11] = inpt[2].v.Ep;\n"
"    p[12] = inpt[2].v.Em;\n"
"    p[13] = inpt[2].v.Fp;\n"
"    p[14] = inpt[2].v.Fm;\n"
"\n"
"    p[15] = inpt[3].v.position;\n"
"    p[16] = inpt[3].v.Ep;\n"
"    p[17] = inpt[3].v.Em;\n"
"    p[18] = inpt[3].v.Fp;\n"
"    p[19] = inpt[3].v.Fm;\n"
"\n"
"    vec3 q[16];\n"
"\n"
"    float U = 1-u, V=1-v;\n"
"\n"
"    float d11 = u+v; if(u+v==0.0f) d11 = 1.0f;\n"
"    float d12 = U+v; if(U+v==0.0f) d12 = 1.0f;\n"
"    float d21 = u+V; if(u+V==0.0f) d21 = 1.0f;\n"
"    float d22 = U+V; if(U+V==0.0f) d22 = 1.0f;\n"
"\n"
"    q[ 5] = (u*p[3] + v*p[4])/d11;\n"
"    q[ 6] = (U*p[9] + v*p[8])/d12;\n"
"    q[ 9] = (u*p[19] + V*p[18])/d21;\n"
"    q[10] = (U*p[13] + V*p[14])/d22;\n"
"\n"
"    q[ 0] = p[0];\n"
"    q[ 1] = p[1];\n"
"    q[ 2] = p[7];\n"
"    q[ 3] = p[5];\n"
"    q[ 4] = p[2];\n"
"    q[ 7] = p[6];\n"
"    q[ 8] = p[16];\n"
"    q[11] = p[12];\n"
"    q[12] = p[15];\n"
"    q[13] = p[17];\n"
"    q[14] = p[11];\n"
"    q[15] = p[10];\n"
"\n"
"    vec3 WorldPos  = vec3(0, 0, 0);\n"
"    vec3 Tangent   = vec3(0, 0, 0);\n"
"    vec3 BiTangent = vec3(0, 0, 0);\n"
"\n"
"#ifdef OSD_COMPUTE_NORMAL_DERIVATIVES\n"
"    float B[4], D[4], C[4];\n"
"    vec3 BUCP[4], DUCP[4], CUCP[4];\n"
"    vec3 dUU = vec3(0);\n"
"    vec3 dVV = vec3(0);\n"
"    vec3 dUV = vec3(0);\n"
"\n"
"    Univar4x4(u, B, D, C);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        BUCP[i] = vec3(0);\n"
"        DUCP[i] = vec3(0);\n"
"        CUCP[i] = vec3(0);\n"
"\n"
"        for (uint j=0; j<4; ++j) {\n"
"            // reverse face front\n"
"            vec3 A = q[i + 4*j];\n"
"\n"
"            BUCP[i] += A * B[j];\n"
"            DUCP[i] += A * D[j];\n"
"            CUCP[i] += A * C[j];\n"
"        }\n"
"    }\n"
"\n"
"    Univar4x4(v, B, D, C);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        WorldPos  += B[i] * BUCP[i];\n"
"        Tangent   += B[i] * DUCP[i];\n"
"        BiTangent += D[i] * BUCP[i];\n"
"        dUU += B[i] * CUCP[i];\n"
"        dVV += C[i] * BUCP[i];\n"
"        dUV += D[i] * DUCP[i];\n"
"    }\n"
"\n"
"    int level = int(inpt[0].v.ptexInfo.z);\n"
"    BiTangent *= 3 * level;\n"
"    Tangent *= 3 * level;\n"
"    dUU *= 6 * level;\n"
"    dVV *= 6 * level;\n"
"    dUV *= 9 * level;\n"
"\n"
"    vec3 n = cross(Tangent, BiTangent);\n"
"    vec3 normal = normalize(n);\n"
"\n"
"    float E = dot(Tangent, Tangent);\n"
"    float F = dot(Tangent, BiTangent);\n"
"    float G = dot(BiTangent, BiTangent);\n"
"    float e = dot(normal, dUU);\n"
"    float f = dot(normal, dUV);\n"
"    float g = dot(normal, dVV);\n"
"\n"
"    vec3 Nu = (f*F-e*G)/(E*G-F*F) * Tangent + (e*F-f*E)/(E*G-F*F) * BiTangent;\n"
"    vec3 Nv = (g*F-f*G)/(E*G-F*F) * Tangent + (f*F-g*E)/(E*G-F*F) * BiTangent;\n"
"\n"
"    Nu = Nu/length(n) - n * (dot(Nu,n)/pow(dot(n,n), 1.5));\n"
"    Nv = Nv/length(n) - n * (dot(Nv,n)/pow(dot(n,n), 1.5));\n"
"\n"
"    BiTangent = (ModelViewMatrix * vec4(BiTangent, 0)).xyz;\n"
"    Tangent = (ModelViewMatrix * vec4(Tangent, 0)).xyz;\n"
"\n"
"    normal = normalize(cross(BiTangent, Tangent));\n"
"\n"
"    outpt.v.Nu = Nu;\n"
"    outpt.v.Nv = Nv;\n"
"\n"
"#else\n"
"    float B[4], D[4];\n"
"    vec3 BUCP[4], DUCP[4];\n"
"\n"
"    Univar4x4(u, B, D);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        BUCP[i] =  vec3(0);\n"
"        DUCP[i] =  vec3(0);\n"
"\n"
"        for (uint j=0; j<4; ++j) {\n"
"            // reverse face front\n"
"            vec3 A = q[i + 4*j];\n"
"\n"
"            BUCP[i] += A * B[j];\n"
"            DUCP[i] += A * D[j];\n"
"        }\n"
"    }\n"
"\n"
"    Univar4x4(v, B, D);\n"
"\n"
"    for (int i=0; i<4; ++i) {\n"
"        WorldPos  += B[i] * BUCP[i];\n"
"        Tangent   += B[i] * DUCP[i];\n"
"        BiTangent += D[i] * BUCP[i];\n"
"    }\n"
"    int level = int(inpt[0].v.ptexInfo.z);\n"
"    BiTangent *= 3 * level;\n"
"    Tangent *= 3 * level;\n"
"\n"
"    BiTangent = (ModelViewMatrix * vec4(BiTangent, 0)).xyz;\n"
"    Tangent = (ModelViewMatrix * vec4(Tangent, 0)).xyz;\n"
"\n"
"    vec3 normal = normalize(cross(BiTangent, Tangent));\n"
"\n"
"#endif\n"
"\n"
"    outpt.v.position = ModelViewMatrix * vec4(WorldPos, 1.0f);\n"
"    outpt.v.normal = normal;\n"
"    outpt.v.tangent = BiTangent;\n"
"    outpt.v.bitangent = Tangent;\n"
"\n"
"    OSD_USER_VARYING_PER_EVAL_POINT(vec2(u,v), 0, 3, 1, 2);\n"
"\n"
"    outpt.v.patchCoord = inpt[0].v.patchCoord;\n"
"    outpt.v.patchCoord.xy = vec2(v, u);\n"
"\n"
"    OSD_COMPUTE_PTEX_COORD_TESSEVAL_SHADER;\n"
"\n"
"    OSD_DISPLACEMENT_CALLBACK;\n"
"\n"
"    gl_Position = ModelViewProjectionMatrix * vec4(WorldPos, 1.0f);\n"
"}\n"
"\n"
"#endif\n"
"\n"
