"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"#version 430\n"
"\n"
"subroutine void computeKernelType();\n"
"subroutine uniform computeKernelType computeKernel;\n"
"\n"
"uniform int vertexOffset = 0;   // vertex index offset for the batch\n"
"uniform int tableOffset = 0;    // offset of subdivision table\n"
"uniform int indexStart = 0;     // start index relative to tableOffset\n"
"uniform int indexEnd = 0;       // end index relative to tableOffset\n"
"uniform bool vertexPass;\n"
"\n"
"/*\n"
" +-----+---------------------------------+-----\n"
"   n-1 |   Level n   |<batch range>|     |  n+1\n"
" +-----+---------------------------------+-----\n"
"       ^             ^             ^\n"
"  vertexOffset       |             |\n"
"                 indexStart     indexEnd\n"
"*/\n"
"\n"
"layout(binding=0) buffer vertex_buffer  { float vertexBuffer[]; };\n"
"layout(binding=1) buffer varying_buffer { float varyingBuffer[]; };\n"
"layout(binding=2) buffer _F0_IT         { int _F_IT[]; };\n"
"layout(binding=3) buffer _F0_ITa        { int _F_ITa[]; };\n"
"layout(binding=4) buffer _E0_IT         { int _E_IT[]; };\n"
"layout(binding=5) buffer _V0_IT         { int _V_IT[]; };\n"
"layout(binding=6) buffer _V0_ITa        { int _V_ITa[]; };\n"
"layout(binding=7) buffer _E0_S          { float _E_W[]; };\n"
"layout(binding=8) buffer _V0_S          { float _V_W[]; };\n"
"layout(binding=9) buffer _editIndices_buffer  { int _editIndices[]; };\n"
"layout(binding=10) buffer _editValues_buffer  { float _editValues[]; };\n"
"layout(local_size_x=WORK_GROUP_SIZE, local_size_y=1, local_size_z=1) in;\n"
"\n"
"//--------------------------------------------------------------------------------\n"
"\n"
"struct Vertex\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    float vertexData[NUM_VERTEX_ELEMENTS];\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    float varyingData[NUM_VARYING_ELEMENTS];\n"
"#endif\n"
"};\n"
"\n"
"void clear(out Vertex v)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for(int i = 0; i < NUM_VARYING_ELEMENTS; i++){\n"
"        v.varyingData[i] = 0;\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"Vertex readVertex(int index)\n"
"{\n"
"    Vertex v;\n"
"\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] = vertexBuffer[index*NUM_VERTEX_ELEMENTS+i];\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        v.varyingData[i] = varyingBuffer[index*NUM_VARYING_ELEMENTS+i];\n"
"    }\n"
"#endif\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(int index, Vertex v)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        vertexBuffer[index*NUM_VERTEX_ELEMENTS+i] = v.vertexData[i];\n"
"    }\n"
"#endif\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        varyingBuffer[index*NUM_VARYING_ELEMENTS+i] = v.varyingData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, Vertex src, float weight)\n"
"{\n"
"#if NUM_VERTEX_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VERTEX_ELEMENTS; i++) {\n"
"        v.vertexData[i] += weight * src.vertexData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"void addVaryingWithWeight(inout Vertex v, Vertex src, float weight)\n"
"{\n"
"#if NUM_VARYING_ELEMENTS > 0\n"
"    for (int i = 0; i < NUM_VARYING_ELEMENTS; i++) {\n"
"        v.varyingData[i] += weight * src.varyingData[i];\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"//--------------------------------------------------------------------------------\n"
"// Face-vertices compute Kernel\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeFace()\n"
"{\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int h = _F_ITa[2*i];\n"
"    int n = _F_ITa[2*i+1];\n"
"\n"
"    float weight = 1.0/n;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"    for(int j=0; j<n; ++j){\n"
"        int index = _F_IT[h+j];\n"
"        addWithWeight(dst, readVertex(index), weight);\n"
"        addVaryingWithWeight(dst, readVertex(index), weight);\n"
"    }\n"
"    writeVertex(vid, dst);\n"
"}\n"
"\n"
"// Edge-vertices compute Kernepl\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeEdge()\n"
"{\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int eidx0 = _E_IT[4*i+0];\n"
"    int eidx1 = _E_IT[4*i+1];\n"
"    int eidx2 = _E_IT[4*i+2];\n"
"    int eidx3 = _E_IT[4*i+3];\n"
"    ivec4 eidx = ivec4(eidx0, eidx1, eidx2, eidx3);\n"
"\n"
"    float vertWeight = _E_W[i*2+0];\n"
"\n"
"    // Fully sharp edge : vertWeight = 0.5f;\n"
"    addWithWeight(dst, readVertex(eidx.x), vertWeight);\n"
"    addWithWeight(dst, readVertex(eidx.y), vertWeight);\n"
"\n"
"    if(eidx.z != -1){\n"
"        float faceWeight = _E_W[i*2+1];\n"
"\n"
"        addWithWeight(dst, readVertex(eidx.z), faceWeight);\n"
"        addWithWeight(dst, readVertex(eidx.w), faceWeight);\n"
"    }\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addVaryingWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"\n"
"// Edge-vertices compute Kernel (bilinear scheme)\n"
"subroutine(computeKernelType)\n"
"void bilinearComputeEdge()\n"
"{\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    ivec2 eidx = ivec2(_E_IT[2*i+0],\n"
"                       _E_IT[2*i+1]);\n"
"\n"
"    addWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(eidx.x), 0.5f);\n"
"    addVaryingWithWeight(dst, readVertex(eidx.y), 0.5f);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernel (bilinear scheme)\n"
"subroutine(computeKernelType)\n"
"void bilinearComputeVertex()\n"
"{\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    int p = _V_ITa[i];\n"
"\n"
"    addWithWeight(dst, readVertex(p), 1.0f);\n"
"\n"
"    addVaryingWithWeight(dst, readVertex(p), 1.0f);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernels 'A' / k_Crease and k_Corner rules\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeVertexA()\n"
"{\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int n     = _V_ITa[5*i+1];\n"
"    int p     = _V_ITa[5*i+2];\n"
"    int eidx0 = _V_ITa[5*i+3];\n"
"    int eidx1 = _V_ITa[5*i+4];\n"
"\n"
"    float weight = vertexPass ? _V_W[i] : 1.0 - _V_W[i];\n"
"\n"
"    // In the case of fractional weight, the weight must be inverted since\n"
"    // the value is shared with the k_Smooth kernel (statistically the\n"
"    // k_Smooth kernel runs much more often than this one)\n"
"    if (weight>0.0 && weight<1.0 && n > 0)\n"
"        weight=1.0-weight;\n"
"\n"
"    Vertex dst;\n"
"    if(! vertexPass)\n"
"        clear(dst);\n"
"    else\n"
"        dst = readVertex(vid);\n"
"\n"
"    if (eidx0==-1 || (vertexPass==false && (n==-1)) ) {\n"
"        addWithWeight(dst, readVertex(p), weight);\n"
"    } else {\n"
"        addWithWeight(dst, readVertex(p), weight * 0.75f);\n"
"        addWithWeight(dst, readVertex(eidx0), weight * 0.125f);\n"
"        addWithWeight(dst, readVertex(eidx1), weight * 0.125f);\n"
"    }\n"
"    if(! vertexPass)\n"
"        addVaryingWithWeight(dst, readVertex(p), 1);\n"
"\n"
"    writeVertex(vid, dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernels 'B' / k_Dart and k_Smooth rules\n"
"subroutine(computeKernelType)\n"
"void catmarkComputeVertexB()\n"
"{\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int h = _V_ITa[5*i];\n"
"    int n = _V_ITa[5*i+1];\n"
"    int p = _V_ITa[5*i+2];\n"
"\n"
"    float weight = _V_W[i];\n"
"    float wp = 1.0/float(n*n);\n"
"    float wv = (n-2.0) * n * wp;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    addWithWeight(dst, readVertex(p), weight * wv);\n"
"\n"
"    for(int j = 0; j < n; ++j){\n"
"        addWithWeight(dst, readVertex(_V_IT[h+j*2]), weight * wp);\n"
"        addWithWeight(dst, readVertex(_V_IT[h+j*2+1]), weight * wp);\n"
"    }\n"
"    addVaryingWithWeight(dst, readVertex(p), 1);\n"
"    writeVertex(vid, dst);\n"
"}\n"
"\n"
"// Vertex-vertices compute Kernels 'B' / k_Dart and k_Smooth rules\n"
"subroutine(computeKernelType)\n"
"void loopComputeVertexB()\n"
"{\n"
"    float PI = 3.14159265358979323846264;\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    int vid = i + vertexOffset;\n"
"    i += tableOffset;\n"
"\n"
"    int h = _V_ITa[5*i];\n"
"    int n = _V_ITa[5*i+1];\n"
"    int p = _V_ITa[5*i+2];\n"
"\n"
"    float weight = _V_W[i];\n"
"    float wp = 1.0/n;\n"
"    float beta = 0.25 * cos(PI*2.0f*wp)+0.375f;\n"
"    beta = beta * beta;\n"
"    beta = (0.625f-beta)*wp;\n"
"\n"
"    Vertex dst;\n"
"    clear(dst);\n"
"\n"
"    addWithWeight(dst, readVertex(p), weight * (1.0-(beta*n)));\n"
"\n"
"    for(int j = 0; j < n; ++j){\n"
"        addWithWeight(dst, readVertex(_V_IT[h+j]), weight * beta);\n"
"    }\n"
"    addVaryingWithWeight(dst, readVertex(p), 1);\n"
"    writeVertex(vid, dst);\n"
"}\n"
"\n"
"// vertex edit kernel\n"
"uniform int editPrimVarOffset;\n"
"uniform int editPrimVarWidth;\n"
"\n"
"subroutine(computeKernelType)\n"
"void editAdd()\n"
"{\n"
"    int i = int(gl_GlobalInvocationID.x) + indexStart;\n"
"    if (i >= indexEnd) return;\n"
"    i += tableOffset;\n"
"\n"
"    int v = _editIndices[i];\n"
"    Vertex dst = readVertex(v + vertexOffset);\n"
"\n"
"    // seemingly we can't iterate dynamically over vertexData[n]\n"
"    // due to mysterious glsl runtime limitation...?\n"
"    for (int j = 0; j < NUM_VERTEX_ELEMENTS; ++j) {\n"
"        float editValue = _editValues[i*editPrimVarWidth + min(j, editPrimVarWidth)];\n"
"        editValue *= float(j >= editPrimVarOffset);\n"
"        editValue *= float(j < (editPrimVarWidth + editPrimVarOffset));\n"
"        dst.vertexData[j] += editValue;\n"
"    }\n"
"    writeVertex(v + vertexOffset, dst);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    // call subroutine\n"
"    computeKernel();\n"
"}\n"
"\n"
